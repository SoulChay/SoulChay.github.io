<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>22Cheney.</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-29T07:38:45.635Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Soulchay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单点登录</title>
    <link href="http://example.com/2022/06/29/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2022/06/29/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2022-06-29T00:39:18.000Z</published>
    <updated>2022-06-29T07:38:45.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>本文原出处：<a href="https://developer.aliyun.com/article/636281#slide-2">单点登录（SSO）看这一篇就够了</a></p><h2 id="1-解释"><a href="#1-解释" class="headerlink" title="1.解释"></a>1.解释</h2><p>单点登录英文全称Single Sign On，简称就是SSO。它的解释是：<b>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</b></p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/SSO/20220629153653.png"/><p>如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。</p><h2 id="2-技术实现"><a href="#2-技术实现" class="headerlink" title="2.技术实现"></a>2.技术实现</h2><p>在说单点登录（SSO）的技术实现之前，我们先说一说普通的登录认证机制。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/SSO/20220629153725.png"/><p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p><h2 id="3-同域下的单点登录"><a href="#3-同域下的单点登录" class="headerlink" title="3.同域下的单点登录"></a>3.同域下的单点登录</h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p><p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p><ul><li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li><li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li></ul><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/SSO/20220629153748.png"/><p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<b>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</b></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p><p>同域下的单点登录就实现了，<b>但这还不是真正的单点登录。</b></p><h2 id="4-不同域下的单点登录"><a href="#4-不同域下的单点登录" class="headerlink" title="4.不同域下的单点登录"></a>4.不同域下的单点登录</h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p><p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。<br><img src= "http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/SSO/20220629153805.png"/></p><p>上图是CAS官网上的标准流程，具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，<b>以后图中的CAS Server我们统一叫做SSO系统。</b>SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><p><b>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</b></p><p><b>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</b></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li><b>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</b></li><li><b>各个业务系统获得的信息是，这个用户能不能访问我的资源。</b></li><li><b>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</b>&gt;</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0.写在前面&quot;&gt;&lt;/a&gt;0.写在前面&lt;/h2&gt;&lt;p&gt;本文原出处：&lt;a href=&quot;https://developer.aliyun.com/article/63</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://example.com/2022/06/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/06/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-06-02T00:39:18.000Z</published>
    <updated>2022-06-02T01:40:53.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485392&idx=1&sn=b8561840166e147b05fd647acbb4b3fd&scene=21#wechat_redirect">《对线面试官》 Java内存模型</a>，方便查阅记忆整理出来的。</p><h2 id="为什么要有Java内存模型"><a href="#为什么要有Java内存模型" class="headerlink" title="为什么要有Java内存模型"></a>为什么要有Java内存模型</h2><ol><li>现有计算机往往是多核的，每个核心下会有高速缓存。高速缓存的诞生是由于「CPU与内存(主存)的速度存在差异」，L1和L2缓存一般是「每个核心独占」一份的。</li><li>为了让CPU提高运算效率，处理器可能会对输入的代码进行「乱序执行」，也就是所谓的「指令重排序」</li><li>一次对数值的修改操作往往是非原子性的（比如 <code>i++</code> 实际上在计算机执行时就会分成多个指令）</li></ol><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093338.png"/><ol start="4"><li><p>在单线程环境下，上面所讲的均不会存在什么问题，因为单线程意味着无并发。并且在单线程下，编译器 &#x2F;runtime&#x2F;处理器 都必须遵守as-if-serial 语义，遵守 as-if-serial 意味着它们不会对「数据依赖关系的操作」做重排序。但是CPU为了效率，有了高速缓存、有了指令重排序等等，整块架构都变得复杂了。我们使用起了多线程。多线程在意味着并发，并发就意味着我们需要考虑线程安全问题</p><ol><li><p>缓存数据不一致：多个线程同时修改「共享变量」，CPU核心下的高速缓存是「不共享」的，那多个cache与内存之间的数据同步该怎么做？</p><ol><li><p>使用「总线锁」：某个核心在修改数据的过程中，其他核心均无法修改内存中的数据。（类似于独占内存的概念，只要有CPU在修改，那别的CPU就得等待当前CPU释放）</p></li><li><p>缓存一致性协议（MESI协议，其实协议有很多，只是举个大家都可能见过的）。MESI拆开英文是（Modified （修改状态）、Exclusive （独占状态）、Share（共享状态）、Invalid（无效状态））。缓存一致性协议我认为可以理解为「缓存锁」，它针对的是「缓存行」(Cache line) 进行”加锁”，所谓「缓存行」其实就是 高速缓存 存储的最小单位。</p></li></ol></li><li><p>CPU指令重排序在多线程下会导致代码在非预期下执行，最终会导致结果存在错误的情况。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093410.png"/></li></ol></li></ol><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>①：当每个CPU读取共享变量之前，会先识别数据的「对象状态」(是修改、还是共享、还是独占、还是无效)。</p><p>②：如果是独占，说明当前CPU将要得到的变量数据是最新的，没有被其他CPU所同时读取</p><p>③：如果是共享，说明当前CPU将要得到的变量数据还是最新的，有其他的CPU在同时读取，但还没被修改</p><p>④：如果是修改，说明当前CPU正在修改该变量的值，同时会向其他CPU发送该数据状态为invalid(无效)的通知，得到其他CPU响应后（其他CPU将数据状态从共享(share)变成invalid(无效)），会当前CPU将高速缓存的数据写到主存，并把自己的状态从modify(修改)变成exclusive(独占)</p><p>⑤：如果是无效，说明当前数据是被改过了，需要从主存重新读取最新的数据。</p><p>⑥：MESI协议做的就是判断「对象状态」，根据「对象状态」做不同的策略。关键就在于某个CPU在对数据进行修改时，需要「同步」通知其他CPU，表示这个数据被我修改了，你们不能用了。</p><p>⑦：比较于「总线锁」，MESI协议的”锁粒度”更小了，性能那肯定会更高</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093419.png"/><h3 id="解决缓存数据不一致"><a href="#解决缓存数据不一致" class="headerlink" title="解决缓存数据不一致"></a>解决缓存数据不一致</h3><p>①：从前面讲到的，可以发现的是：当CPU修改数据时，需要「同步」告诉其他的CPU，等待其他CPU响应接收到invalid(无效)后，它才能将高速缓存数据写到主存。</p><p>②：同步，意味着等待，等待意味着什么都干不了。CPU肯定不乐意啊，所以又优化了一把。优化思路就是从「同步」变成「异步」。</p><p>③：在修改时会「同步」告诉其他CPU，而现在则把最新修改的值写到「store buffer」中，并通知其他CPU记得要改状态，随后CPU就直接返回干其他事了。等到收到其它CPU发过来的响应消息，再将数据更新到高速缓存中。</p><p>④：其他CPU接收到invalid(无效)通知时，也会把接收到的消息放入「invalid queue」中，只要写到「invalid queue」就会直接返回告诉修改数据的CPU已经将状态置为「invalid」</p><p>⑤：而异步又会带来新问题：那我现在CPU修改完A值，写到「store buffer」了，CPU就可以干其他事了。那如果该CPU又接收指令需要修改A值，但上一次修改的值还在「store buffer」中呢，没修改至高速缓存呢。所以CPU在读取的时候，需要去「store buffer」看看存不存在，存在则直接取，不存在才读主存的数据。【Store Forwarding】</p><p>⑥：好了，解决掉第一个异步带来的问题了。（相同的核心对数据进行读写，由于异步，很可能会导致第二次读取的还是旧值，所以首先读「store buffer」。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093425.png"/><h3 id="解决CPU指令重排序（内存屏障）"><a href="#解决CPU指令重排序（内存屏障）" class="headerlink" title="解决CPU指令重排序（内存屏障）"></a>解决CPU指令重排序（内存屏障）</h3><p>①：「异步化」会导致相同核心读写共享变量有问题，也会导致「不同」核心读写共享变量有问题啊</p><p>②：CPU1修改了A值，已把修改后值写到「store buffer」并通知CPU2对该值进行invalid(无效)操作，而CPU2可能还没收到invalid(无效)通知，就去做了其他的操作，导致CPU2读到的还是旧值。即便CPU2收到了invalid(无效)通知，但CPU1的值还没写到主存，那CPU2再次向主存读取的时候，还是旧值…</p><p>③：变量之间很多时候是具有「相关性」(a&#x3D;1;b&#x3D;0;b&#x3D;a)，这对于CPU又是无感知的…</p><p>④：总体而言，由于CPU对「缓存一致性协议」进行的异步优化「store buffer」「invalid queue」，很可能导致后面的指令很可能查不到前面指令的执行结果（各个指令的执行顺序非代码执行顺序），这种现象很多时候被称作「CPU乱序执行」</p><p>⑤：为了解决乱序问题（也可以理解为可见性问题，修改完没有及时同步到其他的CPU），又引出了「内存屏障」的概念。「内存屏障」其实就是为了解决「异步优化」导致「CPU乱序执行」&#x2F;「缓存不及时可见」的问题，那怎么解决的呢？就是把「异步优化」给”禁用“掉</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093449.png"><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>①：内存屏障可以分为三种类型：写屏障，读屏障以及全能屏障（包含了读写屏障），屏障可以简单理解为：在操作数据的时候，往数据插入一条”特殊的指令”。只要遇到这条指令，那前面的操作都得「完成」。</p><p>②：那写屏障就可以这样理解：CPU当发现写屏障的指令时，会把该指令「之前」存在于「store Buffer」所有写指令刷入高速缓存。</p><p>③：通过这种方式就可以让CPU修改的数据可以马上暴露给其他CPU，达到「写操作」可见性的效果</p><p>④：读屏障也是类似的：CPU当发现读屏障的指令时，会把该指令「之前」存在于「invalid queue」所有的指令都处理掉</p><p>⑤：通过这种方式就可以确保当前CPU的缓存状态是准确的，达到「读操作」一定是读取最新的效果。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093458.png"/><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>①：由于不同CPU架构的缓存体系不一样、缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化Java开发人员的工作。Java封装了一套规范，这套规范就是「Java内存模型」</p><p>②：再详细地说，「Java内存模型」希望 屏蔽各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果。目的是解决多线程存在的原子性、可见性（缓存一致性）以及有序性问题。</p><p>③：所以，Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093505.png"/><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>①：Java内存模型它是一种「规范」，Java虚拟机会实现这个规范。</p><p>②：Java内存模型主要的内容，我个人觉得有以下几块吧</p><ol><li>Java内存模型的抽象结构</li><li>happen-before 规则</li><li>对volatile 内存语义</li></ol><h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><p>①：Java内存模型定义了：Java线程对内存数据进行交互的规范。线程之间的「共享变量」存储在「主内存」中，每个线程都有自己私有的「本地内存」，「本地内存」存储了该线程以读&#x2F;写共享变量的副本。本地内存是Java内存模型的抽象概念，并不是真实存在的。</p><p>②：Java内存模型规定了：线程对变量的所有操作都必须在「本地内存」进行，「不能直接读写主内存」的变量。Java内存模型定义了8种操作来完成「变量如何从主内存到本地内存，以及变量如何从本地内存到主内存」。分别是read&#x2F;load&#x2F;use&#x2F;assign&#x2F;store&#x2F;write&#x2F;lock&#x2F;unlock操作。看着8个操作很多，对变量的一次读写就涵盖了这些操作了。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093835.png"/><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093905.png"/><h3 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h3><p>①：happen-before实际上也是一套「规则」。Java内存模型定义了这套规则，目的是为了阐述「操作之间」的内存「可见性」。</p><p>②：在CPU和编译器层面上都有指令重排的问题。指令重排虽然是能提高运行的效率，但在并发编程中，我们在兼顾「效率」的前提下，还希望「程序结果」能由我们掌控的。说白了就是：在某些重要的场景下，这一组操作都不能进行重排序，「前面一个操作的结果对后续操作必须是可见的」。</p><p>③：于是，Java内存模型就提出了happen-before这套规则，规则总共有8条，比如传递性、volatile变量规则、程序顺序规则、监视器锁的规则…（具体看规则的含义就好了，这块不难）</p><p>④：我们写的代码只要在 happen-before 这些规则下，前一个操作的结果对后续操作是可见的，是不会发生重排序的。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093928.png"/><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>①：特性：可见性和有序性(禁止重排序)</p><p>②：而Java内存模型这个规范，很大程度下就是为了解决可见性和有序性的问题。</p><h3 id="volatile-的可见性和有序性"><a href="#volatile-的可见性和有序性" class="headerlink" title="volatile 的可见性和有序性"></a>volatile 的可见性和有序性</h3><p>①：Java内存模型为了实现volatile有序性和可见性，定义了4种内存屏障的「规范」，分别是 LoadLoad&#x2F;LoadStore&#x2F;StoreLoad&#x2F;StoreStore</p><p>②：说白了，就是在volatile「前后」加上「内存屏障」，使得编译器和CPU无法进行重排序，致使有序，并且写volatile变量对其他线程可见。</p><p>③：Java内存模型定义了规范，那Java虚拟机就得实现。Hotspot虚拟机在「汇编」层面上实际是通过Lock前缀指令来实现的，lock指令能保证：禁止CPU和编译器的重排序（保证了有序性）、保证CPU写核心的指令可以立即生效且其他核心的缓存数据失效（保证了可见性）。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602093959.png"/><h3 id="volatile-和-MESI协议的关系"><a href="#volatile-和-MESI协议的关系" class="headerlink" title="volatile 和 MESI协议的关系"></a>volatile 和 MESI协议的关系</h3><p>①：它们没有直接的关联。</p><p>②：Java内存模型关注的是编程语言层面上，它是高维度的抽象。MESI 是CPU缓存一致性协议，不同的CPU架构都不一样，可能有的CPU压根就没用MESI协议…只不过MESI名声大，大家就都拿他来举例子了。而MESI可能只是在「特定的场景下」为实现 volatile 的可见性&#x2F;有序性而使用到的一部分罢了</p><p>③：为了让Java程序员屏蔽上面这些底层知识，快速地入门使用volatile变量。Java内存模型的 happen-before 规则中就有对 volatile 变量规则的定义。这条规则的内容其实就是：对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见。它通过happen-before规则来规定：只要变量声明了volatile 关键字，写后再读，读必须可见写的值。（可见性、有序性）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5M</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 八股文</title>
    <link href="http://example.com/2022/06/01/ThreadLocal%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/06/01/ThreadLocal%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-06-01T04:59:21.000Z</published>
    <updated>2022-06-01T12:35:59.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485314&idx=1&sn=cab8fb85edd454cb32ee7c0da6ab107d&scene=21#wechat_redirect">《对线面试官》ThreadLocal</a> ，方便查阅记忆整理出来的。</p><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>①：ThreadLocal是一个壳子，真正的存储结构是 ThreadLocal 里有 ThreadLocalMap 这么个内部类</p><p>②：ThreadLocalMap 的引用是在Thread上定义的</p><p>③：ThreadLocal本身并不存储值，它只是作为 key 来让线程从 ThreadLocalMap 获取 value</p><p>④：得出的结论就是 ThreadLocalMap 该结构本身就在 Thread下 定义，而 ThreadLocal 只是作为 key，存储到 ThreadLocalMap 的变量当然是线程私有的。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220601202202.png"></img></p><h2 id="为什么ThreadLocal作为key，而不是Thread作为key？"><a href="#为什么ThreadLocal作为key，而不是Thread作为key？" class="headerlink" title="为什么ThreadLocal作为key，而不是Thread作为key？"></a>为什么ThreadLocal作为key，而不是Thread作为key？</h2><p>①：理论上是可以，但没那么优雅。</p><p>②：你提出的做法实际上就是所有的线程都访问ThreadLocal的Map，而key是当前线程</p><p>③：但这有点小问题，一个线程是可以拥有多个私有变量的嘛，那key如果是当前线程的话，意味着还点做点「手脚」来唯一标识set进去的value</p><p>④：假设上一步解决了，还有个问题就是；并发量足够大时，意味着所有的线程都去操作同一个Map，Map体积有可能会膨胀，导致访问性能的下降</p><p>⑤：这个Map维护着所有的线程的私有变量，意味着你不知道什么时候可以「销毁」</p><p>⑥：现在JDK实现的结构就不一样了。线程需要多个私有变量，那有多个ThreadLocal对象足以，对应的Map体积不会太大，只要线程销毁了，ThreadLocalMap也会被销毁</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220601202228.png"/><h2 id="内存泄漏是什么"><a href="#内存泄漏是什么" class="headerlink" title="内存泄漏是什么"></a>内存泄漏是什么</h2><p>内存泄漏：申请内存后用完但没有释放掉，自己没法用，系统又没法回收。</p><h2 id="讲一讲-ThreadLocal-的内存泄露"><a href="#讲一讲-ThreadLocal-的内存泄露" class="headerlink" title="讲一讲 ThreadLocal 的内存泄露"></a>讲一讲 ThreadLocal 的内存泄露</h2><p>①：ThreadLocal内存泄露指的是：ThreadLocal 被回收了，ThreadLocalMap Entry 的 key 没有了指向，发生的概率非常低。</p><p>②：回到原理上，我们知道 Thread 在创建的时候，会有栈引用指向 Thread对象，Thread对象内部维护了 ThreadLocalMap 引用，而 ThreadLocalMap 的Key是 ThreadLocal，value 是传入的 Object，ThreadLocal 对象会被对应的栈引用关联，ThreadLocalMap 的key也指向着 ThreadLocal，即</p><ul><li><code>ThreadLocalRef &amp;&amp; ThreadLocalMap Entry key -&gt; ThreadLocal</code></li><li><code>ThreadRef-&gt;Thread-&gt;ThreadLoalMap-&gt; Entry value-&gt; Object</code></li></ul><p>③：ThreadLocal 现在被回收了，但Entry仍然有 <code>ThreadRef-&gt;Thread-&gt;ThreadLoalMap-&gt; Entry value-&gt; Object </code> 这条引用一直存在，这就导致了内存泄露</p><p>④：为什么说导致内存泄露的概率非常低呢？</p><ol><li><p>首先ThreadLocal被两种引用指向</p><ul><li><p><code>ThreadLocalRef-&gt; ThreadLocal（强引用）</code></p></li><li><p><code>ThreadLocalMap Entry key -&gt; ThreadLocal（弱引用）</code></p></li></ul></li><li><p>只要 ThreadLocal 没被回收（使用时强引用不置null），那 ThreadLocalMap Entry key 的指向就不会在GC时断开被回收，也没有内存泄露一说法。</p></li><li><p>通过 ThreadLocal 了解实现后，又 ThreadLocalMap 是依附在Thread上的，只要 Thread 销毁，那 ThreadLocalMap 也会销毁，那非线程池环境下，也不会有长期性的内存泄露问题</p></li><li><p>而ThreadLocal实现下还做了些 “保护” 措施，如果在操作 ThreadLocal 时，发现 key 为 null，会将其清除掉。所以，如果在线程池（线程复用）环境下，如果还会调用 ThreadLocal 的 set&#x2F;get&#x2F;remove 方法，发现 key 为 null 会进行清除，不会有长期性的内存泄露问题</p></li><li><p>那存在长期性内存泄露需要满足条件：ThreadLocal 被回收 &amp;&amp; 线程被复用 &amp;&amp; 线程复用后不再调用 ThreadLocal 的 set&#x2F;get&#x2F;remove 方法</p></li><li><p>使用ThreadLocal的最佳实践就是：用完了，手动remove掉。</p></li></ol><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220601202250.png" alt="图片" style="zoom:80%;" /><h2 id="为什么将-ThreadLocalMap-的key-设置为弱引用"><a href="#为什么将-ThreadLocalMap-的key-设置为弱引用" class="headerlink" title="为什么将 ThreadLocalMap 的key 设置为弱引用"></a>为什么将 ThreadLocalMap 的key 设置为弱引用</h2><p>①：外界是通过 ThreadLocal 来对 ThreadLocalMap 进行操作的，假设外界使用 ThreadLocal 的对象被置null了，那 ThreadLocalMap 的强引用指向 ThreadLocal 会毫无意义。</p><p>②：弱引用反而可以预防大多数内存泄漏的情况，毕竟被回收后，下一次调用 set&#x2F;get&#x2F;remove 时 ThreadLocal 内部会清除掉</p><h2 id="为什么网上有很多人建议把ThreadLocal修饰为static"><a href="#为什么网上有很多人建议把ThreadLocal修饰为static" class="headerlink" title="为什么网上有很多人建议把ThreadLocal修饰为static"></a>为什么网上有很多人建议把ThreadLocal修饰为static</h2><p>①：ThreadLocal 能实现了线程的数据隔离，不在于它自己本身，而在于 Thread 的 ThreadLocalMap</p><p>②：所以，ThreadLocal 可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。</p><h2 id="ThreadLocal实际用处（举例）"><a href="#ThreadLocal实际用处（举例）" class="headerlink" title="ThreadLocal实际用处（举例）"></a><strong>ThreadLocal实际用处</strong>（举例）</h2><p>①：Spring提供了事务相关的操作，而我们知道事务是得保证一组操作同时成功或失败的，这意味着我们一次事务的所有操作需要在同一个数据库连接上，但是在我们日常写代码的时候是不需要关注这点的</p><p>②：Spring 就是用的 ThreadLocal 来实现，ThreadLocal 存储的类型是一个 Map</p><p>③：Map 中的 key 是DataSource，value 是Connection（为了应对多数据源的情况，所以是一个Map）</p><p>④：用了 ThreadLocal 保证了同一个线程获取一个 Connection 对象，从而保证一次事务的所有操作需要在同一个数据库连接上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5M</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS &amp; Synchronized 八股文</title>
    <link href="http://example.com/2022/05/31/CAS&amp;Synchronized%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/05/31/CAS&amp;Synchronized%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-05-31T10:29:31.000Z</published>
    <updated>2022-06-02T05:07:44.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485234&idx=1&sn=17adffb6c4342b7e75213ce64d13a03c&scene=21#wechat_redirect">《对线面试官》CAS</a>  和 <a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485246&idx=1&sn=265bcc56ba59a089eaeea47244d840d8&scene=21#wechat_redirect">《对线面试官》synchronized</a>，方便查阅记忆整理出来的。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p>①：CAS的全称为 <code>Compare And Swap</code> ，比较并交换，它是一个原子性的操作，对应到CPU指令为 <code>cmpxchg</code></p><p>②：CAS 有三个操作数：当前值A、内存值V、要修改的新值B。假设 当前值A 跟 内存值V 相等，那就将 内存值V 改成B。假设 当前值A 跟 内存值V 不相等，要么就重试，要么就放弃更新。</p><p>③：将当前值与内存值进行对比，判断是否有被修改过，这就是CAS的核心</p><h3 id="为什么要用CAS"><a href="#为什么要用CAS" class="headerlink" title="为什么要用CAS"></a>为什么要用CAS</h3><p>①：因为synchronized锁每次只会让一个线程去操作共享资源，效率太低。</p><p>②：而CAS相当于没有加锁，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断能否修改成功。</p><p>③：在很多的情况下会比 synchronized锁 要高效很多，比如，对一个值进行累加，就没必要使用synchronized锁，使用 juc 包下的 Atomic类就足以。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>①：从CAS更新的时候，我们可以发现它只比对当前值和内存值是否相等，这会带来个问题</p><p>②：举例说明下：假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10。等到线程A拿到执行权时，因为当前值和内存值是一致的，线程A是可以修改的！这就是ABA问题</p><p>③：解决ABA的问题：Java提供了 <code>AtomicStampedReference</code> 类供我们用，说白了就是加了个版本，比对的就是内存值和版本是否一致</p><h3 id="比较-LongAdder-amp-AtomicLong"><a href="#比较-LongAdder-amp-AtomicLong" class="headerlink" title="比较 LongAdder&amp;AtomicLong"></a>比较 LongAdder&amp;AtomicLong</h3><p>①：<code>AtomicLong</code> 做累加的时候实际上就是多个线程操作同一个目标资源。在高并发时，只有一个线程是执行成功的，其他的线程都会失败，不断自旋（重试），自旋会成为瓶颈。</p><p>②：而 <code>LongAdder</code> 的思想就是把要操作的目标资源「分散」到数组Cell中。每个线程对自己的 Cell 变量的 value 进行原子操作，最终将base和cell中的值 <code>sum()</code> 求和，就会得到最终的结果了，大大降低了失败的次数。这就是为什么在高并发场景下，推荐使用 <code>LongAdder</code>  的原因。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="什么是-synchronized"><a href="#什么是-synchronized" class="headerlink" title="什么是 synchronized"></a>什么是 synchronized</h3><p>①：synchronized是一种互斥锁，一次只能允许一个线程进入被锁住的代码块</p><p>②：synchronized是Java的一个关键字，它能够将代码块&#x2F;方法锁起来</p><ul><li>如果synchronized修饰的是实例方法，对应的锁则是对象实例</li><li>如果synchronized修饰的是静态方法，对应的锁则是当前类的Class实例</li><li>如果synchronized修饰的是代码块，对应的锁则是传入synchronized的对象实例</li></ul><h3 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h3><p>①：通过反编译可以发现，当修饰方法时，编译器会生成 ACC_SYNCHRONIZED 关键字用来标识。</p><p>②：当修饰代码块时，会依赖monitorenter和monitorexit指令，但前面已经说了，无论synchronized修饰的是方法还是代码块，对应的锁都是一个实例（对象），在内存中。</p><p>③：对象一般由三部分组成，分别是对象头、对象实际数据和对齐填充，重点在于对象头，对象头又由几部分组成，其中Mark Word会记录对象关于锁的信息，又因为每个对象都会有一个与之对应的 <code>monitor</code>对象，<code>monitor</code>对象中存储着当前持有锁的线程以及等待锁的线程队列</p><h3 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h3><p>①：在JDK 1.6之前是重量级锁，线程进入同步代码块&#x2F;方法 时，monitor对象就会把当前进入线程的Id进行存储，设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中。</p><p>②：它加锁是依赖底层操作系统的 mutex 相关指令实现，所以会有用户态和内核态之间的切换，性能损耗十分明显，而JDK1.6 以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，就没有切换的消耗，所以，Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183240.png"></img></p><p>偏向锁：JVM会认为只有某个线程才会执行同步代码（没有竞争的环境）。所以在Mark Word会直接记录线程ID，只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码。如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码。如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为轻量级锁。</p><p>轻量级锁：在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，LockRecord 会把Mark Word的信息拷贝进去，且有个Object指针指向加锁的对象。线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的Lock Record，假设CAS修改成功，则获取得到轻量级锁。假设修改失败，则自旋（重试），自旋一定次数后，则升级为重量级锁。例如现在Thread1想获得锁，但是锁正在被Thread0拥有，Thread1自旋多次都无法获取锁，这时候就会升级为重量级锁</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602130246.png"/><p>重量级锁：为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220602130018.png"></img></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>①：synchronized锁原来只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗十分明显</p><p>②：重量级锁用到monitor对象，而偏向锁则在 Mark Word 记录线程ID进行比对，轻量级锁则是拷贝 Mark Word 到 Lock Record，采用CAS + 自旋 的方式获取。</p><p>③：引入了偏向锁和轻量级锁，就是为了在不同的使用场景使用不同的锁，进而提高效率。锁只有升级，没有降级</p><ul><li>只有一个线程进入临界区，偏向锁</li><li>多个线程交替进入临界区，轻量级锁</li><li>多线程同时进入临界区，重量级锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5M</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS&amp;ReentrantLock</title>
    <link href="http://example.com/2022/05/31/AQS&amp;ReentrantLock/"/>
    <id>http://example.com/2022/05/31/AQS&amp;ReentrantLock/</id>
    <published>2022-05-31T09:59:21.000Z</published>
    <updated>2022-06-02T03:14:27.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485258&idx=1&sn=c6f631613c0a5c120e24893905e1e5dc&scene=21#wechat_redirect">《对线面试官》AQS和ReentrantLock</a> ，方便查阅记忆整理出来的。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>①：公平锁指的就是：在竞争环境下，先到临界区的线程比后到的线程一定更快地获取得到锁</p><p>②：非公平锁指的是：先到临界区的线程未必比后到的线程更快地获取得到锁</p><p>③：所以公平和非公平的区别就是：线程执行同步代码块时，是否会去尝试获取锁。如果会尝试获取锁，那就是非公平的。如果不会尝试获取锁，直接进队列，再等待唤醒，那就是公平的。</p><h2 id="实现公平锁和非公平锁"><a href="#实现公平锁和非公平锁" class="headerlink" title="实现公平锁和非公平锁"></a>实现公平锁和非公平锁</h2><p>①：公平锁可以把竞争的线程放在一个先进先出的队列上，只要持有锁的线程执行完了，唤醒队列的下一个线程去获取锁就好了</p><p>②：非公平锁：线程先尝试能不能获取得到锁，如果获取得到锁了就执行同步代码，如果获取不到锁，那就再把这个线程放到队列中</p><h2 id="非公平锁的实现中获取不到锁为什么要进队列呢？线程一直尝试获取锁不就行了么？"><a href="#非公平锁的实现中获取不到锁为什么要进队列呢？线程一直尝试获取锁不就行了么？" class="headerlink" title="非公平锁的实现中获取不到锁为什么要进队列呢？线程一直尝试获取锁不就行了么？"></a>非公平锁的实现中获取不到锁为什么要进队列呢？线程一直尝试获取锁不就行了么？</h2><p>一直尝试获取锁，专业点就叫做自旋，多个线程一直在自旋，而且大多数都是竞争失败的，需要耗费资源的。</p><h2 id="说说synchronized锁为什么是非公平锁"><a href="#说说synchronized锁为什么是非公平锁" class="headerlink" title="说说synchronized锁为什么是非公平锁"></a>说说synchronized锁为什么是非公平锁</h2><p>①：偏向锁很好理解，如果当前线程ID与markword存储的不相等，则CAS尝试更换线程ID，CAS成功就获取得到锁了，CAS失败则升级为轻量级锁</p><p>②：轻量级锁实际上也是通过CAS来抢占锁资源（只不过多了拷贝Mark Word到Lock Record的过程），抢占成功到锁就归属给该线程了，但自旋失败一定次数后升级重量级锁</p><p>③：重量级锁通过monitor对象中的队列存储线程，但线程进入队列前，还是会先尝试获取得到锁，如果获取不到才进入线程等待队列中</p><p>④：综上所述，synchronized无论处理哪种锁状态，都是先尝试获取，获取不到才 锁升级 or 放到队列上的，所以是非公平的</p><h2 id="说说AQS"><a href="#说说AQS" class="headerlink" title="说说AQS"></a>说说AQS</h2><p>①：AQS全称叫做 <code>AbstractQueuedSynchronizer</code> ，是个可以给我们实现锁的一个「框架」，内部实现的关键就是维护了一个先进先出的队列以及state状态变量。简单理解就是：AQS定义了模板，具体实现由各个子类完成。</p><ul><li>先进先出队列存储的载体叫做Node节点，该节点标识着当前的状态值、是独占还是共享模式以及它的前驱和后继节点等等信息。</li><li>state变量则表示为当前锁的状态。</li></ul><p>②：总体的流程可以总结为：会把需要等待的线程以Node的形式放到这个先进先出的队列上。</p><p>③：像ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore这些常用的实现类都是基于AQS实现的</p><p>④：AQS支持两种模式：独占（锁只会被一个线程独占）和共享（多个线程可同时执行）</p><h2 id="讲讲加锁和解锁的过程"><a href="#讲讲加锁和解锁的过程" class="headerlink" title="讲讲加锁和解锁的过程"></a>讲讲加锁和解锁的过程</h2><p>以ReentrantLock为例</p><p>①：对于非公平锁，我们在外界调用lock方法的时候，源码是这样实现的</p><ul><li>CAS尝试获取锁，获取成功则可以执行同步代码</li><li>CAS获取失败，则调用acquire方法，acquire方法实际上就是AQS的模板方法</li><li>acquire首先会调用子类的tryAcquire方法（又回到了ReentrantLock中）</li><li>tryAcquire方法实际上会判断当前的state是否等于0，等于0说明没有线程持有锁，则又尝试CAS直接获取锁</li><li>如果CAS获取成功，则可以执行同步代码</li><li>如果CAS获取失败，那判断当前线程是否持有锁，如果是持有的锁，那更新state的值，获取得到锁（这里其实就是处理可重入的逻辑）</li><li>CAS失败&amp;&amp;非重入的情况，则回到tryAcquire方法执行「入队列」的操作</li><li>将节点入队列之后，会判断「前驱节点」是不是头节点，如果是头结点又会用CAS尝试获取锁</li><li>如果是「前驱节点」是头节点并获取得到锁，则把当前节点设置为头结点，并且将前驱节点置空（实际上就是原有的头节点已经释放锁了）</li><li>没获取到锁，则判断前驱节点的状态是否为SIGNAL，如果不是，则找到合法的前驱节点，并使用CAS将状态设置为SIGNAL</li><li>最后调用park将当前线程挂起</li><li>总结一下加锁的过程：当线程CAS获取锁失败，将当前线程入队列，把前驱节点状态设置为 <code>SIGNAL</code> 状态，并将自己挂起。</li></ul><p>②：解锁过程</p><ul><li>外界调用unlock方法时，实际上会调用AQS的release方法，而release方法会调用子类tryRelease方法（又回到了ReentrantLock中）</li><li>tryRelease会把state一直减（锁重入可使state&gt;1），直至到0，当前线程说明已经把锁释放了</li><li>随后从队尾往前找节点状态需要 &lt; 0，并离头节点最近的节点进行唤醒</li><li>唤醒之后，被唤醒的线程则尝试使用CAS获取锁，假设获取锁得到则把头节点置为空，把自己设置为头节点</li><li>总结一下解锁的逻辑非常简单：把state置0，唤醒头结点下一个合法的节点，被唤醒的节点线程自然就会去获取锁</li></ul><p>③：为什么要设置前驱节点为SIGNAL状态</p><ul><li>其实归终结底就是为了判断节点的状态，去做些处理。</li><li>Node 中节点的状态有4种，分别是：CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)和0</li><li>在ReentrantLock解锁的时候，会判断节点的状态是否小于0，小于等于0才说明需要被唤醒</li><li>另外一提的是：公平锁的实现与非公平锁是很像的，只不过在获取锁时不会直接尝试使用CAS来获取锁。只有当队列没节点并且state为0时才会去获取锁，不然都会把当前线程放到队列中</li></ul><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183136.png"></img></p><h2 id="说说waitStatus"><a href="#说说waitStatus" class="headerlink" title="说说waitStatus"></a>说说waitStatus</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CANCELLED：由于超时或中断，此节点被取消。节点一旦被取消了就不会再改变状态。特别是，取消节点的线程不会再阻塞。</span><br><span class="line">static final int CANCELLED =  1;</span><br><span class="line">// SIGNAL:此节点后面的节点已（或即将）被阻止（通过park），因此当前节点在释放或取消时必须断开后面的节点</span><br><span class="line">// 为了避免竞争，acquire方法时前面的节点必须是SIGNAL状态，然后重试原子acquire，然后在失败时阻塞。</span><br><span class="line">static final int SIGNAL    = -1;</span><br><span class="line">// 此节点当前在条件队列中。标记为CONDITION的节点会被移动到一个特殊的条件等待队列（此时状态将设置为0），直到条件时才会被重新移动到同步等待队列 。（此处使用此值与字段的其他用途无关，但简化了机制。）</span><br><span class="line">static final int CONDITION = -2;</span><br><span class="line">//传播：应将releaseShared传播到其他节点。这是在doReleaseShared中设置的（仅适用于头部节点），以确保传播继续，即使此后有其他操作介入。</span><br><span class="line">static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">//0:以上数值均未按数字排列以简化使用。非负值表示节点不需要发出信号。所以，大多数代码不需要检查特定的值，只需要检查符号。</span><br><span class="line">//对于正常同步节点，该字段初始化为0；对于条件节点，该字段初始化为条件。它是使用CAS修改的（或者在可能的情况下，使用无条件的volatile写入）。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5M</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池八股文</title>
    <link href="http://example.com/2022/05/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/05/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-05-31T08:59:21.000Z</published>
    <updated>2022-06-04T10:34:40.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h2><p>①：JVM在HotSpot的线程模型下，Java线程会一对一映射为内核线程。这意味着，在Java中每次创建以及回收线程都会去内核创建以及回收，这就有可能导致创建和销毁线程所花费的时间和资源可能比处理的任务花费的时间和资源要更多</p><p>②：线程池的出现是为了提高线程的复用性以及固定线程的数量。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220604135653.png"/><h2 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h2><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h2 id="CPU-密集任务-amp-IO-密集任务"><a href="#CPU-密集任务-amp-IO-密集任务" class="headerlink" title="CPU 密集任务 &amp; IO 密集任务"></a>CPU 密集任务 &amp; IO 密集任务</h2><p>①：CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。</p><p>②：但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220604135308.png"/><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(MyBlockQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    nanos = emptyCondition.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">            fullCondition.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">            fullCondition.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞生产</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待加入任务队列  ...&quot;</span> + task);</span><br><span class="line">                    fullCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入任务队列  ...&quot;</span> + task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyCondition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时阻塞生产</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task,<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待加入任务队列  ...&quot;</span> + task);</span><br><span class="line">                    nanos = fullCondition.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入任务队列  ...&quot;</span> + task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyCondition.signal();</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有空闲</span></span><br><span class="line">                System.out.println(<span class="string">&quot;加入任务队列 &quot;</span> + task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyCondition.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池封装"><a href="#线程池封装" class="headerlink" title="线程池封装"></a>线程池封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">//任务数没有超过 coreSize 时，交给Worker对象执行</span></span><br><span class="line">        <span class="comment">//任务数超过 coreSize 时，进入阻塞队列</span></span><br><span class="line">        <span class="keyword">if</span> (workers.size() &lt;= coreSize) &#123;</span><br><span class="line">            <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">            System.out.println(<span class="string">&quot;新增 worker  ...&quot;</span>+ worker + <span class="string">&quot; --- &quot;</span>+task);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeOut, </span></span><br><span class="line"><span class="params">                      TimeUnit timeUnit, <span class="type">int</span> queueCapacity, RejectPolicy rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeOut = timeOut;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || </span><br><span class="line">                   (task = taskQueue.poll(timeOut, timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;正在执行  ...&quot;</span> + task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;worker被移除  ...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                    workers.remove(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line">            queue.put(task);</span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line">            <span class="comment">// queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">            <span class="comment">// log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">            <span class="comment">// throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            <span class="comment">//task.run();</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>①：看阿里巴巴开发手册就有提到，不要使用Executors去创建线程。最主要的目的就是：使用ThreadPoolExecutor创建的线程你是更能了解线程池运行的规则，避免资源耗尽的风险</p><p>②：ThreadPoolExecutor在构造的时候有几个重要的参数，分别是：corePoolSize（核心线程数量）、maximumPoolSize（最大线程数量）、keepAliveTime（线程空余时间，当前运行的线程数大于核心线程数了，只要空闲时间达到了，就会对线程进行回收）、workQueue（阻塞队列）、handler（任务拒绝策略）</p><ul><li>首先会判断运行线程数是否小于corePoolSize，如果小于，则直接创建新的线程执行任务</li><li>如果大于corePoolSize，判断workQueue阻塞队列是否已满，如果还没满，则将任务放到阻塞队列中</li><li>如果workQueue阻塞队列已经满了，则判断当前线程数是否大于maximumPoolSize，如果没大于则创建新的线程执行任务</li><li>如果大于maximumPoolSize，则执行任务拒绝策略（具体就是你自己实现的handler）</li><li>这里有个点需要注意下，就是workQueue阻塞队列满了，但当前线程数小于maximumPoolSize，这时候会创建新的线程执行任务</li></ul><p>③：源码就是这样实现的，不过一般我们都是将corePoolSize和maximumPoolSize设置相同数量</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220604135538.png"/><h2 id="指定线程数问题"><a href="#指定线程数问题" class="headerlink" title="指定线程数问题"></a>指定线程数问题</h2><p>①：线程池指定线程数这块，首先要考量自己的业务是什么样的</p><p>②：是cpu密集型的还是io密集型的，假设运行应用的机器CPU核心数是N</p><p>③：那cpu密集型的可以先给到N+1，io密集型的可以给到2N去试试</p><p>④：上面这个只是一个常见的经验做法，具体究竟开多少线程，需要压测才能比较准确地定下来</p><p>⑤：线程不是说越大越好，多线程是为了充分利用CPU的资源，如果设置的线程过多，线程大量有上下文切换，这一部分也会带来系统的开销，这就得不偿失了</p><h2 id="说说几种常见的线程池及使用场景"><a href="#说说几种常见的线程池及使用场景" class="headerlink" title="说说几种常见的线程池及使用场景"></a>说说几种常见的线程池及使用场景</h2><ol><li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</li><li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。可以用于已知并发压力的情况下，对线程数做限制。</li><li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li><li>newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。</li></ol><h2 id="说说线程池的拒绝策略"><a href="#说说线程池的拒绝策略" class="headerlink" title="说说线程池的拒绝策略"></a>说说线程池的拒绝策略</h2><ol><li><p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</p></li><li><p>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</p></li><li><p>DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p></li><li><p>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</p></li><li><p>自定义拒绝策略：实现RejectedExecutionHandler接口</p></li></ol><h2 id="execute和submit的区别"><a href="#execute和submit的区别" class="headerlink" title="execute和submit的区别"></a>execute和submit的区别</h2><p>①：execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了。</p><p>②：submit方法适用于需要关注返回值的场景</p><h2 id="shutdownNow-和-shutdown的区别"><a href="#shutdownNow-和-shutdown的区别" class="headerlink" title="shutdownNow 和 shutdown的区别"></a>shutdownNow 和 shutdown的区别</h2><p>①：都是用于线程关闭</p><p>②：shutdownNow：对正在执行的任务发出interrupt()，停止执行，对还未开始执行的任务全部取消，且返回还没开始的任务列表。</p><p>③：shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><h2 id="线程池中的几种重要的参数"><a href="#线程池中的几种重要的参数" class="headerlink" title="线程池中的几种重要的参数"></a>线程池中的几种重要的参数</h2><ul><li><p>corePoolSize：线程池中的核心线程数量，这几个核心线程，即使在没有用的时候，也不会被回收</p></li><li><p>maximumPoolSize：线程池中可以容纳的最大线程的数量</p></li><li><p>keepAliveTime：线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，</p></li><li><p>util：计算这个时间的一个单位。</p></li><li><p>workQueue：等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p></li><li><p>threadFactory：创建线程的线程工厂。</p></li><li><p>handler：拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么需要线程池&quot;&gt;&lt;a href=&quot;#为什么需要线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池&quot;&gt;&lt;/a&gt;为什么需要线程池&lt;/h2&gt;&lt;p&gt;①：JVM在HotSpot的线程模型下，Java线程会一对一映射为内核线程。这意味着，在Ja</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础</title>
    <link href="http://example.com/2022/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-31T06:29:31.000Z</published>
    <updated>2022-06-01T10:43:35.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>①：进程是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源</p><p>②：进程实现多处理机环境下的进程调度，分派，切换时，都需要花费较大的时间和空间开销</p><p>③：为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理，所以有了线程，线程取代了进程了调度的基本功能。简单来说，进程作为资源分配的基本单位，线程作为资源调度的基本单位</p><h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><p>①：使用多线程最主要的原因是提高系统的资源利用率。</p><p>②：现在CPU基本都是多核的，如果只用单线程，那就是只用到了一个核心，其他的核心就相当于空闲在那里了。</p><p>③：多线程应用举例：</p><ul><li><p>Tomcat处理每一个请求都会从线程连接池里边用一个线程去处理。</p></li><li><p>连接数据库会用对应的连接池 Druid&#x2F;C3P0&#x2F;DBCP…</p></li></ul><h2 id="实际开发中多线程的使用"><a href="#实际开发中多线程的使用" class="headerlink" title="实际开发中多线程的使用"></a>实际开发中多线程的使用</h2><p>比如说，现在要跑一个定时任务，该任务的链路执行时间和过程都非常长，我这边就用一个线程池将该定时任务的请求进行处理。</p><p>这样做的好处就是可以及时返回结果给调用方，能够提高系统的吞吐量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求直接交给线程池来处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(PushParam pushParam)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    pushServiceThreadExecutor.submit(() -&gt; &#123;</span><br><span class="line">      handler(pushParam);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;pushServiceThreadExecutor error, exception&#123;&#125;:&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是我的系统中用了很多生产者与消费者模式，会用多个线程去消费队列的消息，来提高并发度</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在我的理解下，在Java世界里边，所谓线程安全就是多个线程去执行某类，这个类始终能表现出正确的行为，那么这个类就是线程安全的。</p><p>比如我有一个count变量，在service方法不断的累加这个count变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCountingServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        ++count;</span><br><span class="line">        <span class="comment">// To something else...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设相同的条件下，count变量每次执行的结果都是相同，那我们就可以说是线程安全的。显然上面的代码肯定不是线程安全的。</p><h2 id="怎么解决线程安全问题"><a href="#怎么解决线程安全问题" class="headerlink" title="怎么解决线程安全问题"></a>怎么解决线程安全问题</h2><p>思路有以下:</p><ul><li><p>能不能保证操作的原子性，考虑 <code>atomic</code>包下的类够不够我们使用。</p></li><li><p>能不能保证操作的可见性，考虑 <code>volatile</code> 关键字 够不够我们使用</p></li><li><p>如果涉及到对线程的控制（比如一次能使用多少个线程，当前线程触发的条件是否依赖其他线程的结果），考虑 <code>CountDownLatch/Semaphore</code> 等等。</p></li><li><p>如果是集合，考虑 <code>java.util.concurrent</code> 包下的集合类。</p></li><li><p>如果 <code>synchronized</code> 无法满足，考虑 <code>lock</code> 包下的类</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601184258.png" alt="图片" style="zoom:67%;" /></li></ul><p>总的来说，就是先判断有没有线程安全问题，如果存在则根据具体的情况去判断使用什么方式去处理线程安全的问题。虽然 <code>synchronized</code> 很有效果，但无脑使用是会影响我们程序的性能的。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>造成死锁的原因可以简单概括为：当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，但是都不放弃自己拥有的资源。</p><p>避免死锁的方式一般有以下方案：</p><ol><li>固定加锁的顺序，比如我们可以使用Hash值的大小来确定加锁的先后</li><li>尽可能缩减加锁的范围，等到操作共享变量的时候才加锁。</li><li>使用可释放的定时锁（一段时间申请不到锁的权限了，直接释放掉）</li></ol><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601184316.png"/>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别&quot;&gt;&lt;/a&gt;进程和线程的区别&lt;/h2&gt;&lt;p&gt;①：进程是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>验证IP地址</title>
    <link href="http://example.com/2022/05/29/%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/"/>
    <id>http://example.com/2022/05/29/%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/</id>
    <published>2022-05-29T07:19:00.000Z</published>
    <updated>2022-05-29T07:17:48.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>纪念一道 “非常没水平的题”。</p><p>今天是 2022.5.29，一个月没碰算法题目了，今天心血来潮想刷刷题目。</p><p>打开力扣每日一题，直接开干！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">468. 验证IP地址</span><br><span class="line">给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 &quot;IPv4&quot; ；如果是有效的 IPv6 地址，返回 &quot;IPv6&quot; ；如果不是上述类型的 IP 地址，返回 &quot;Neither&quot; 。</span><br><span class="line"></span><br><span class="line">有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 &lt;= xi &lt;= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。</span><br><span class="line"></span><br><span class="line">一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:</span><br><span class="line">1. 1 &lt;= xi.length &lt;= 4</span><br><span class="line">2. xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( &#x27;a&#x27; 到 &#x27;f&#x27; )和大写英文字母( &#x27;A&#x27; 到 &#x27;F&#x27; )。</span><br><span class="line">3. 在 xi 中允许前导零。</span><br><span class="line">例如 &quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; 和 &quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot; 是有效的 IPv6 地址，而 &quot;2001:0db8:85a3::8A2E:037j:7334&quot; 和 &quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; 是无效的 IPv6 地址。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：queryIP = &quot;172.16.254.1&quot;</span><br><span class="line">输出：&quot;IPv4&quot;</span><br><span class="line">解释：有效的 IPv4 地址，返回 &quot;IPv4&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：queryIP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br><span class="line">输出：&quot;IPv6&quot;</span><br><span class="line">解释：有效的 IPv6 地址，返回 &quot;IPv6&quot;</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：queryIP = &quot;256.256.256.256&quot;</span><br><span class="line">输出：&quot;Neither&quot;</span><br><span class="line">解释：既不是 IPv4 地址，又不是 IPv6 地址</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode.cn/problems/validate-ip-address</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>好家伙，我一看就笑了，这不就是平时写程序的 <code>if + else if + else</code> 嘛，就这还中等题？ 面向应用编程是叭？</p><p>结果过了40多分钟我才进行第一次提交，1小时左右才AC，别问我那20分钟改什么了，只能说太粗心了😭。</p><p>而且我的代码，真的是又臭又长😑，贴上来给你们看看。。。</p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">validIPAddress</span><span class="params">(String queryIP)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(judgeIPv4(queryIP))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(judgeIPv6(queryIP))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeIPv4</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有3个点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pointCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;.&#x27;</span>) pointCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pointCnt != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理前三个点前面的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> str.substring(<span class="number">0</span>,index);</span><br><span class="line">            <span class="keyword">if</span>(!judge4(str1)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//更新str</span></span><br><span class="line">            str = str.substring(index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理第三个冒号后剩下的字符串</span></span><br><span class="line">        <span class="keyword">return</span> judge4(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge4</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//1.长度过长过短或者前置为0则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() &lt; <span class="number">1</span> || str.length() &gt; <span class="number">3</span> || (str.length() &gt; <span class="number">1</span> &amp;&amp; str.indexOf(<span class="string">&quot;0&quot;</span>) == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//2.判断每个字符是否都是数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;str.length(); m++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(m);</span><br><span class="line">            <span class="keyword">if</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.判断数字的范围是否合法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">strInt</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">        <span class="keyword">if</span>(strInt &lt; <span class="number">0</span> || strInt &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeIPv6</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有7个冒号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pointCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;:&#x27;</span>) pointCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pointCnt != <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理前七个冒号前面的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> str.substring(<span class="number">0</span>,index);</span><br><span class="line">            <span class="keyword">if</span>(!judge6(str1)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//更新str</span></span><br><span class="line">            str = str.substring(index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理第三个冒号后剩下的字符串</span></span><br><span class="line">        <span class="keyword">return</span> judge6(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge6</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//1.长度过长则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() &lt; <span class="number">1</span> || str.length() &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//2.判断每个字符是否都是数字或字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;str.length(); m++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(m);</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>说实话，这道题真的是出的”非常没水平”，但确实是我们在编写程序时最常遇到的情景，非常考验我们思维的缜密性。以我的代码作为反例，如果只追求满足需求就完事，而不考虑其他一些更优雅的方法，写的代码只会越来越 “Shit 山”。好嘞我要去改我的代码了，拜拜拜拜！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;纪念一道 “非常没水平的题”。&lt;/p&gt;
&lt;p&gt;今天是 2022.5.29，一个月没碰算法题目了，今天心血来潮想刷刷题目。&lt;/</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>学院项目的知识点巩固</title>
    <link href="http://example.com/2022/05/27/%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/"/>
    <id>http://example.com/2022/05/27/%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/</id>
    <published>2022-05-27T03:20:00.000Z</published>
    <updated>2022-05-29T11:06:25.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据库属性自动装配"><a href="#1-数据库属性自动装配" class="headerlink" title="1. 数据库属性自动装配"></a>1. 数据库属性自动装配</h2><p>自动注入插入时间和更新时间</p><p>在日常的开发过程中，DAO层的数据库实体类(Entity)中经常会有一些公共字段如 create_by(创建人)，create_time(创建时间) 等字段，与业务基本无关且属于记录本身的属性字段。这些字段通常会容易被大家忽视，每个 Entity 都去处理一遍比较麻烦耗时；如果忽略又会造成记录本身属性不完整。</p><p>可以使用 <code>MybatisPlus</code> 中的  <code>MetaObjectHandler</code> 来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于插入时对公共字段的填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于更新时对公共字段的填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装配配置:自动注入插入时间和更新时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Swagger-配置"><a href="#2-Swagger-配置" class="headerlink" title="2. Swagger 配置"></a>2. Swagger 配置</h2><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/educationOnline/1.png"></img></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">            <span class="comment">// 用来创建该API的基本信息，展示在文档的页面中（自定义展示的信息）</span></span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">            <span class="comment">// 设置哪些接口暴露给Swagger展示</span></span><br><span class="line">                .select()</span><br><span class="line">            <span class="comment">//错误路径不监控</span></span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加摘要信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;网站-课程中心API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了课程中心微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;SoulChay&quot;</span>, <span class="string">&quot;http://soulchay.com&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;1837522825@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-异常处理类"><a href="#3-异常处理类" class="headerlink" title="3. 异常处理类"></a>3. 异常处理类</h2><p>我们可以使用 <code>@ControllerAdvice</code> 配合 <code>@ExceptionHandler</code> 来设置处理全局异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一异常处理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span> <span class="comment">//本质上是一个Component，作用是给Controller控制器添加统一的操作或处理。</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一般异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> R.error().message(<span class="string">&quot;执行全局异常处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SoulException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">error</span><span class="params">(GuliException e)</span>&#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> R.error().code(e.getCode()).message(e.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-GateWay-处理跨域"><a href="#4-GateWay-处理跨域" class="headerlink" title="4. GateWay 处理跨域"></a>4. GateWay 处理跨域</h2><p>可以使用 <code>@CrossOrigin</code> 来处理跨域，但是每个请求都添加一遍实在是太磨人，所以采用 GateWay 来处理跨域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 允许的请求头</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的请求源 （如：http://localhost:8080）</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的请求方法 ==&gt; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加URL映射，这里拦截一切请求</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>(<span class="keyword">new</span> <span class="title class_">PathPatternParser</span>());</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于跨域配置会进行叠加，使用 GateWay 进行跨域处理后，需要关闭其他跨域的处理，不然前端会报错。 </p><h2 id="5-Cacheable-的使用"><a href="#5-Cacheable-的使用" class="headerlink" title="5. @Cacheable 的使用"></a>5. @Cacheable 的使用</h2><p>@Cacheable可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。</p><p>需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。</p><p>@Cacheable可以指定三个属性，value、key和condition。</p><p> value属性是必须指定的。其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Cacheable(“cache1”)</span><span class="comment">//Cache是发生在cache1上的</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Cacheable(&#123;“cache1”, “cache2”&#125;)</span><span class="comment">//Cache是发生在cache1和cache2上的</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。</p><p>先来看看自定义策略。 自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=”users”, key=”#id”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Cacheable(value=”users”, key=”#p0”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Cacheable(value=”users”, key=”#user.id”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Cacheable(value=”users”, key=”#p0.id”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述使用方法参数作为key之外，Spring还为我们提供了一个 root 对象可以用来生成key。通过该root对象我们可以获取到以下信息。</p><table><thead><tr><th>属性名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>methodName</td><td>当前方法名</td><td>#root.methodName</td></tr><tr><td>method</td><td>当前方法</td><td>#root.method.name</td></tr><tr><td>target</td><td>当前被调用的对象</td><td>#root.target</td></tr><tr><td>targetClass</td><td>当前被调用的对象的class</td><td>#root.targetClass</td></tr><tr><td>args</td><td>当前方法参数组成的数组</td><td>#root.args[0]</td></tr><tr><td>caches</td><td>当前被调用的方法使用的Cache</td><td>#root.caches[0].name</td></tr></tbody></table><p>当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=&#123;“users”, “xxx”&#125;, key=”caches[1].name”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=&#123;“users”&#125;, key=”#user.id”, condition=”#user.id%2==0”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(“find user by user “ + user);</span><br><span class="line"> <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6. 分页查询"></a>6. 分页查询</h2><p>配置分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.soul.eduservice.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EduConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高版本的SpringBoot中, 会提示这种写法<b>已过时</b>, 所以采用另一种写法 <b>MybatisPlusInterceptor</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.H2));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分页代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EduTeacherServiceImpl</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;EduTeacherMapper, EduTeacher&gt; <span class="keyword">implements</span> <span class="title class_">EduTeacherService</span> &#123;</span><br><span class="line">    <span class="comment">//分页查询讲师方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getTeacherFrontList</span><span class="params">(Page&lt;EduTeacher&gt; pageTeacher)</span> &#123;</span><br><span class="line">        QueryWrapper&lt;EduTeacher&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        baseMapper.selectPage(pageTeacher,queryWrapper);</span><br><span class="line"></span><br><span class="line">        List&lt;EduTeacher&gt; records = pageTeacher.getRecords();  <span class="comment">//获取当前页的数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> pageTeacher.getCurrent();  <span class="comment">//当前页码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">pages</span> <span class="operator">=</span> pageTeacher.getPages();  <span class="comment">//page数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageTeacher.getTotal();  <span class="comment">//获取总记录数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> pageTeacher.getSize();  <span class="comment">//page大小</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPrevious</span> <span class="operator">=</span> pageTeacher.hasPrevious();  <span class="comment">//是否还有上一页</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasNext</span> <span class="operator">=</span> pageTeacher.hasNext(); <span class="comment">//是否还有下一页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把分页数据取出，放到map集合</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;items&quot;</span>,records);</span><br><span class="line">        map.put(<span class="string">&quot;pages&quot;</span>,pages);</span><br><span class="line">        map.put(<span class="string">&quot;current&quot;</span>,current);</span><br><span class="line">        map.put(<span class="string">&quot;total&quot;</span>,total);</span><br><span class="line">        map.put(<span class="string">&quot;size&quot;</span>,size);</span><br><span class="line">        map.put(<span class="string">&quot;hasNext&quot;</span>,hasNext);</span><br><span class="line">        map.put(<span class="string">&quot;hasPrevious&quot;</span>,hasPrevious);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Feign-远程调用"><a href="#7-Feign-远程调用" class="headerlink" title="7. Feign 远程调用"></a>7. Feign 远程调用</h2><p>实现模块A调用模块B的方法</p><p>①：导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--服务调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②：模块A：</p><p>启动类添加注解 <code>@EnableFeignClients</code> 启用 fegin 客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//nacos注册</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.soul&quot;&#125;)</span> <span class="comment">//添加扫描Config包的注解</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>  <span class="comment">//远程调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EduApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EduApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个客户端类来调用模块B的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;service-order&quot;,fallback = OrdersClientImpl.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrdersClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据课程id和用户id查询订单表中订单状态</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/eduorder/order/isBuyCourse/&#123;courseId&#125;/&#123;memberId&#125;&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBuyCourse</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> String courseId, <span class="meta">@PathVariable(&quot;memberId&quot;)</span> String memberId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③：模块B：</p><p>模块A所调用的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/eduorder/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据课程id和用户id查询订单表中订单状态</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;isBuyCourse/&#123;courseId&#125;/&#123;memberId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBuyCourse</span><span class="params">(<span class="meta">@PathVariable</span> String courseId,<span class="meta">@PathVariable</span> String memberId)</span> &#123;</span><br><span class="line">        QueryWrapper&lt;Order&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;course_id&quot;</span>,courseId);</span><br><span class="line">        wrapper.eq(<span class="string">&quot;member_id&quot;</span>,memberId);</span><br><span class="line">        wrapper.eq(<span class="string">&quot;status&quot;</span>,<span class="number">1</span>);<span class="comment">//支付状态 1代表已经支付</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> orderService.count(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>) &#123; <span class="comment">//已经支付</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-配置文件的读取"><a href="#8-配置文件的读取" class="headerlink" title="8. 配置文件的读取"></a>8. 配置文件的读取</h2><p>实现项目初始化时就对配置文件进行读取，需要实现 <code>InitializingBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取properties中所需的密钥等信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantPropertiesUtils</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123; <span class="comment">// 项目初始化时就对信息进行读取</span></span><br><span class="line">    <span class="comment">//读取配置文件内容</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String keyId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String keySecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义公开静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String END_POIND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ACCESSS_KEY_ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ACCESSS_KEY_SECRET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String BUCKET_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        END_POIND = endpoint;</span><br><span class="line">        ACCESSS_KEY_ID = keyId;</span><br><span class="line">        ACCESSS_KEY_SECRET = keySecret;</span><br><span class="line">        BUCKET_NAME = bucketName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-设置定时任务"><a href="#9-设置定时任务" class="headerlink" title="9. 设置定时任务"></a>9. 设置定时任务</h2><p>①：在启动类上添加 <code>@EnableScheduling</code> 注解来开启定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.soul&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">//开启定时任务</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.soul.staservice.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StaApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>②：需要使用 <code>@Scheduled</code> 注解，Cron表达式可在 <a href="https://cron.qqe2.com/">在线Cron表达式生成器生成</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StatisticsDailyService staService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在每天凌晨1点，把前一天数据进行数据查询添加</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> &#123;</span><br><span class="line">        staService.registerCount(DateUtil.formatDate(DateUtil.addDays(<span class="keyword">new</span> <span class="title class_">Date</span>(), -<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-QQ邮箱的使用"><a href="#10-QQ邮箱的使用" class="headerlink" title="10. QQ邮箱的使用"></a>10. QQ邮箱的使用</h2><p>①：导入依赖并在配置文件里配置相关（password如何得到？你去Google一下呗）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#邮箱配置</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">1837522825@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">akigpratjvhdefbc</span></span><br><span class="line"><span class="attr">spring.mail.default-encoding</span>: <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure><p>②：实现简单配置读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String emailFrom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmailFrom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emailFrom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③：相关实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmailConfig emailConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">sendSimpleMail</span><span class="params">(String sendTo)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            code.append((<span class="type">int</span>)(Math.random()*<span class="number">9</span>));<span class="comment">//随机生成六位数验证码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;登录验证&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;您好，您的验证码为 : &quot;</span> + code;</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> emailConfig.getEmailFrom();</span><br><span class="line"></span><br><span class="line">        message.setFrom(email);</span><br><span class="line">        message.setTo(sendTo);</span><br><span class="line">        message.setSubject(title);</span><br><span class="line">        message.setText(content);</span><br><span class="line"></span><br><span class="line">        mailSender.send(message);<span class="comment">//发送邮件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//存到redis中</span></span><br><span class="line">        redisTemplate.opsForValue().set(email,code.toString(),<span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.ok().message(<span class="string">&quot;验证码已发送，5分钟内有效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-阿里云oss服务"><a href="#11-阿里云oss服务" class="headerlink" title="11. 阿里云oss服务"></a>11. 阿里云oss服务</h2><p>①：导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--阿里云oss依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②：配置相关</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阿里云 OSS</span></span><br><span class="line"><span class="attr">aliyun.oss.file.endpoint</span>=<span class="string">#</span></span><br><span class="line"><span class="attr">aliyun.oss.file.keyid</span>=<span class="string">#</span></span><br><span class="line"><span class="attr">aliyun.oss.file.keysecret</span>=<span class="string">#</span></span><br><span class="line"><span class="attr">aliyun.oss.file.bucketname</span>=<span class="string">#</span></span><br></pre></td></tr></table></figure><p>③：代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OssService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传头像到oss</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFileAvatar</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="comment">//获取工具类中的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> ConstantPropertiesUtils.END_POIND;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accesssKeyId</span> <span class="operator">=</span> ConstantPropertiesUtils.ACCESSS_KEY_ID;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accesssKeySecret</span> <span class="operator">=</span> ConstantPropertiesUtils.ACCESSS_KEY_SECRET;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> ConstantPropertiesUtils.BUCKET_NAME;</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建OSS实例</span></span><br><span class="line">            <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accesssKeyId, accesssKeySecret);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上传文件流</span></span><br><span class="line">            inputStream = file.getInputStream();</span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">//在每个文件名前添加随机唯一数值 ---&gt; 防止因文件名相同被覆盖</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//把文件按照日期分类</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTime</span>().toString(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">            originalFilename = dateStr + <span class="string">&quot;/&quot;</span> +uuid + originalFilename;</span><br><span class="line"></span><br><span class="line">            ossClient.putObject(bucketName, originalFilename, inputStream);</span><br><span class="line"></span><br><span class="line">            inputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把上传的文件路径进行拼接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;https://&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint + <span class="string">&quot;/&quot;</span> + originalFilename;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-阿里云视频点播服务"><a href="#12-阿里云视频点播服务" class="headerlink" title="12. 阿里云视频点播服务"></a>12. 阿里云视频点播服务</h2><p>①：引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-vod<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-vod-upload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②：配置相关</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阿里云 vod</span></span><br><span class="line"><span class="attr">aliyun.oss.file.endpoint</span>=<span class="string">#</span></span><br><span class="line"><span class="attr">aliyun.oss.file.bucketname</span>=<span class="string">#</span></span><br><span class="line"><span class="attr">aliyun.vod.file.keyid</span>=<span class="string">#</span></span><br><span class="line"><span class="attr">aliyun.vod.file.keysecret</span>=<span class="string">#</span></span><br></pre></td></tr></table></figure><p>②：上传视频到阿里云</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">VodService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上传视频</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadVideo</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> fileName.substring(<span class="number">0</span>,fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="type">UploadStreamRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadStreamRequest</span>(ConstantVodUtils.ACCESS_KEY_ID,</span><br><span class="line">                    ConstantVodUtils.ACCESS_KEY_SECRET, title, fileName, inputStream);</span><br><span class="line">            <span class="type">UploadVideoImpl</span> <span class="variable">uploader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadVideoImpl</span>();</span><br><span class="line">            <span class="type">UploadStreamResponse</span> <span class="variable">response</span> <span class="operator">=</span> uploader.uploadStream(request);</span><br><span class="line">            <span class="type">String</span> <span class="variable">videoId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                videoId = response.getVideoId();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因</span></span><br><span class="line">                System.out.print(<span class="string">&quot;VideoId=&quot;</span> + response.getVideoId() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                System.out.print(<span class="string">&quot;ErrorCode=&quot;</span> + response.getCode() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                System.out.print(<span class="string">&quot;ErrorMessage=&quot;</span> + response.getMessage() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> videoId;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/pengzhisen123/article/details/94409825">Spring之缓存注解@Cacheable</a></p><p><a href="https://blog.csdn.net/qq_41359651/article/details/112260207">Mybatis-Plus中分页插件PaginationInterceptor， MybatisPlusInterceptor在SpringBoot中的使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-数据库属性自动装配&quot;&gt;&lt;a href=&quot;#1-数据库属性自动装配&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库属性自动装配&quot;&gt;&lt;/a&gt;1. 数据库属性自动装配&lt;/h2&gt;&lt;p&gt;自动注入插入时间和更新时间&lt;/p&gt;
&lt;p&gt;在日常的开发过程中，D</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>nvm 的安装和使用</title>
    <link href="http://example.com/2022/05/22/nvm%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2022/05/22/nvm%E6%8C%87%E4%BB%A4/</id>
    <published>2022-05-22T01:19:00.000Z</published>
    <updated>2022-05-24T03:25:42.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>之前学习了网上一个项目，使用的 node 是 <code>10.14.1</code> 版本的，而部署博客则需要更高版本的 node ，如果每次部署项目和部署博客都要卸载一个版本的 node 下载另一个版本的 node ，真的是太麻烦了。于是在网上找可以管理 node 的工具 nvm。这里使用的是 <code>nvm-windows</code> 的版本。</p><h2 id="2-nvm-下载与安装"><a href="#2-nvm-下载与安装" class="headerlink" title="2. nvm 下载与安装"></a>2. nvm 下载与安装</h2><p>下载地址 ：<a href="https://github.com/coreybutler/nvm-windows/releases">nvm-windows</a></p><p>①：如图所示，两个安装包都可以下载，不过 <code>nvm-noinstall.zip</code> 需要自行配置环境变量，而 <code>nvm-setup.zip</code> 会自动帮我们配置好环境变量，安装好后可以直接使用。这里我选择的是 <code>nvm-setup.zip</code> 。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/1.png"></img></p><p>②：首先要卸载掉之前电脑上下载的 node，运行下载的 <code>nvm-serup.exe</code> 文件，开始安装。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/2.png"></img></p><p>设置 nvm 的安装位置</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/3.png"></img></p><p>设置 node 的安装位置</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/4.png"></img></p><p>然后一直 next 即可。</p><p>③：安装结束后，可以 <code>Win + r</code>，输入<code>sysdm.cpl</code> 在 <code>高级</code> 里查看环境变量，发现环境变量已经帮我们配好了。<code>Path</code>里也添加了这两个变量，<code>Path</code> 这里就不贴图了。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/5.png"></img></p><p>④：安装好后，记得要新建一个文件夹，这个文件夹的位置要与安装 nvm 步骤中设置的 node 的安装位置对应。</p><p>⑤：<code>Win + r</code> ，输入 <code>cmd</code> 进入命令面板，输入<code>nvm</code> 命令即可查看 nvm 是否安装成功。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/6.png"></img> </p><p>如图所示，表示安装成功。</p><p>⑥：接下来就可以安装我们所需要的不同版本的 node 了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如 10.14.1 版本node</span></span><br><span class="line">nvm install 10.14.1</span><br></pre></td></tr></table></figure><p>⑦：安装成功后，可以查看自己的 <code>node</code> 和 <code>npm</code> 版本（我这里之前安装过了，就直接查看版本了）。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/7.png"></img></p><p>如果出现 <code>node 不是内部或外部命令，也不是可运行的程序或批处理文件</code>，可以使用管理员运行。</p><p>⑧：使用命令查看管理的 node 的版本，当前使用的 node 版本前会有个 <code>*</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/nvmOrder/8.png"></img></p><p>⑨：切换 node 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比如切换到 16.14.1 版本</span></span><br><span class="line">nvm use 16.14.1</span><br></pre></td></tr></table></figure><p>大功告成！这样就可以根据自己的需求很方便的切换不同版本的 node 了！</p><p>本文到此也就结束了，最后贴几个常用命令留待以后查阅。</p><h2 id="3-nvm-常用命令"><a href="#3-nvm-常用命令" class="headerlink" title="3. nvm 常用命令"></a>3. nvm 常用命令</h2><p> 显示nvm版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm v     </span><br></pre></td></tr></table></figure><p>显示版本列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示已安装的版本（同 nvm list installed）</span></span><br><span class="line">nvm list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示已安装的版本</span></span><br><span class="line">nvm list installed</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有可以下载的版本</span></span><br><span class="line">nvm list available </span><br></pre></td></tr></table></figure><p>安装指定版本 node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如10.14.2版本node</span></span><br><span class="line">nvm install 10.14.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新版本node</span></span><br><span class="line">nvm install latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新稳定版node.js</span></span><br><span class="line">nvm install stable </span><br></pre></td></tr></table></figure><p>使用指定版本 node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 16.14.1</span><br></pre></td></tr></table></figure><p>卸载指定版本 node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm uninstall 10.14.2 </span><br></pre></td></tr></table></figure><p>关闭 node 版本管理  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm off                </span><br></pre></td></tr></table></figure><p>启用 node 版本管理 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm on    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;之前学习了网上一个项目，使用的 node 是 &lt;code&gt;10.14.1&lt;/code&gt; 版本的，而部署博</summary>
      
    
    
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>encrypt的目录bug</title>
    <link href="http://example.com/2022/05/10/Encrypt%E7%9A%84%E7%9B%AE%E5%BD%95bug/"/>
    <id>http://example.com/2022/05/10/Encrypt%E7%9A%84%E7%9B%AE%E5%BD%95bug/</id>
    <published>2022-05-10T07:08:00.000Z</published>
    <updated>2022-05-24T03:15:59.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>起初是不想搞博文加密的，奈何博客地址不小心泄露给表妹，于是决定还是要折腾一下这个博文加密。</p><p>（😎 ：表妹啊，你就别想敲诈我了！）</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><h3 id="加密文章"><a href="#加密文章" class="headerlink" title="加密文章"></a>加密文章</h3><p>①：在想要加密的博文头部增添 <code>password</code> , <code>abstract</code> , <code>message</code> 字段即可，三个字段可加可不加，不加则采用 <code>_config.yml</code> 配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Test encrypt</span><br><span class="line">date: 2022-05-09 15:08:00 </span><br><span class="line">tags:</span><br><span class="line">- Java</span><br><span class="line">password: hello</span><br><span class="line">abstract: Welcome to my blog, enter password to read. //博客部分摘要</span><br><span class="line">message: Welcome to my blog, enter password to read.  //密码输入框上面的描述性文字</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>②：在<strong>博客根目录</strong> 的<code>_config.yml</code>中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">silent:</span> <span class="literal">true</span> <span class="comment">#禁用日志</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">xray</span>  <span class="comment">#加密的主题（不是hexo主题，可到 github 上 probberechts/hexo-theme-cactus 的 readme.md 查看 ）</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">Please</span> <span class="string">enter</span> <span class="string">password</span> <span class="string">to</span> <span class="string">read</span> <span class="comment">#博客部分摘要</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">Please</span> <span class="string">enter</span> <span class="string">password</span> <span class="string">to</span> <span class="string">read</span>  <span class="comment">#密码输入框上面的描述性文字</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="literal">no</span> <span class="string">Permissions.</span>  <span class="comment">#密码错误提示</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">can</span> <span class="string">not</span> <span class="string">Verify.</span>  <span class="comment">#哈希错误提示</span></span><br></pre></td></tr></table></figure><p>③：<strong>配置优先级</strong>：博文头部配置 &gt; yml文件配置 &gt; 默认配置</p><p>④：若想禁用标签<code>(tag)</code>加密，只需将<code>password</code>属性设置为<code>&quot;&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Callback Test</span><br><span class="line">date: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- A Tag should be encrypted</span><br><span class="line">password: &quot;&quot;</span><br><span class="line">---</span><br><span class="line">Use a &quot;&quot; to disable tag encryption.</span><br></pre></td></tr></table></figure><p>⑤：加密成功演示：</p><ul><li><p>新建一个 <code>markdown</code> 文档并推送到 github ，内容如下。</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/1.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>被加密后的博文界面</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/2.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>输入密码并回车</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/3.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>内容显示成功，并且可以点击 <code>Encrypt again</code> 按钮回到加密界面</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/4.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li></ul><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug!"></a>Bug!</h3><p>当我在为成功实现博文加密功能沾沾自喜（😃）时，突然发现一个问题，<strong>哎我目录呢？！</strong>（ 🤡 ）</p><h3 id="分析Bug"><a href="#分析Bug" class="headerlink" title="分析Bug"></a>分析Bug</h3><p>①：检查目录对应代码，发现解密前后目录标签里面什么都没有</p><ul><li><p>解密前界面</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/5.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>解密后界面</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/6.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li></ul><p>②：因为本人前端部分只能算是小菜鸡，只能用最笨的办法根据标签id去文件里去找了。</p><p>因为是文章部分，所以直接定位到 <code>_partial\post</code>  的各个<code>ejs</code>文件，寻找的方法很简单，<code>CTRL + F</code> 搜索 <code>toc</code> 即可。</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/7.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/><p>③：最终发现 <code>toc</code> 在 <code>actions_desktop.ejs</code> 和 <code>actions_mobile.ejs</code>中出现。见名知意，一个是pc端一个是移动端呗。</p><p>以 pc端为例分析：</p><ul><li><p>发现只有一处地方出现了 <code>toc</code></p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/8.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>而经查略 <a href="https://github.com/D0n9X1n/hexo-blog-encrypt/issues/16">issue</a>，了解到TOC的加载原理是：</p><ul><li>在执行 <code>hexo g</code> 时会按照博文内容生成 TOC，然后默认隐藏不出现。</li><li>在<code>Encrypt</code> 对文章进行加密时，<code>page.content</code> 会变成加密后的串，所以原来 TOC 生成逻辑就会针对加密后的内容。</li></ul></li></ul><p>（🤔）</p><h3 id="解决Bug"><a href="#解决Bug" class="headerlink" title="解决Bug"></a>解决Bug</h3><p>①：原理了解后就可以动手解决Bug了</p><ol><li>可以把文章原来的内容先保存起来，比如保存进 <code>page.origin</code> 字段</li><li>然后可以判断文章是否加密，针对不同的内容进行 TOC 生成。</li><li>但是生成的 TOC 是基于原文的，所以默认隐藏，需要输入密码后才能显示出来</li></ol><p>②：动手解决Bug</p><ul><li><p>pc端（actions_desktop.ejs）：</p><p>原代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc&quot;</span>&gt;</span></span><br><span class="line">&lt;%- toc(page.content) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc&quot;</span> &lt;% <span class="attr">if</span> (<span class="attr">page.encrypt</span> == <span class="string">true)</span> &#123; %&gt;</span>style=&quot;display:none&quot; &lt;% &#125; %&gt;&gt;</span><br><span class="line">&lt;% if (page.encrypt == true) &#123; %&gt;</span><br><span class="line">&lt;%- toc(page.origin) %&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;%- toc(page.content) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>移动端（actions_mobile.ejs ）</p><p>原代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span><br><span class="line">&lt;%- toc(page.content) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一次修改：</p><p>​<b>不起作用，这是因为在每次加载页面时，如果判断当前是移动端，会有js代码帮我们把 <code>style=&quot;display:none&quot;</code> 修改为<code>style=&quot;display:inline&quot;</code></b>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span> </span><br><span class="line">&lt;% if (page.encrypt == true) &#123; %&gt;</span><br><span class="line">&lt;%- toc(page.origin) %&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;%- toc(page.content) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二次修改：</p><p>​<b>知道原因后就简单了，在里面套一个 <code>&lt;div&gt;</code> 标签不就得嘞（😄）</b></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-footer2&quot;</span> &lt;% <span class="attr">if</span> (<span class="attr">page.encrypt</span> == <span class="string">true)</span> &#123; %&gt;</span>style=&quot;display:none&quot; &lt;% &#125; %&gt;&gt;</span><br><span class="line">       &lt;% if (page.encrypt == true) &#123; %&gt;</span><br><span class="line">         &lt;%- toc(page.origin) %&gt;</span><br><span class="line">       &lt;% &#125; else &#123; %&gt;</span><br><span class="line">         &lt;%- toc(page.content) %&gt;</span><br><span class="line">       &lt;% &#125; %&gt;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>③：还差最后一步，每次从 加密状态 -&gt;解密状态 进行切换时，都需要我们自己调用函数，将<code>style=&quot;display: none&quot;</code>修改为<code>style=&quot;display: inline&quot;</code>，确实有点麻烦哈（参考于<a href="https://github.com/D0n9X1n/hexo-blog-encrypt#about-callback">官方</a>的<code>Callback</code>）。</p><p>在需要加密的文章最后加入以下js代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;toc&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;toc&quot;</span>).<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;inline&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;toc-footer2&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;toc-footer2&quot;</span>).<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;inline&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如图：</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/9.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/><p>④：最终测试</p><ul><li><p>pc端未解密界面：没有目录</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/10.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>pc端解密后界面：出现目录</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/11.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>移动端未解密界面：没有目录</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/12.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li><li><p>移动端解密后界面：出现目录</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/encrypt/13.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/></li></ul><p>（😎）</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>（🤺：本人在前端部分只能算是小菜鸡，若有错误，欢迎指正。）</p><p>（😭：还有就是使用cactus主题的前辈们实在太少了，想懒人大法都找不着C的地方。不过这次扒代码，还是很有某种收获吧！）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;起初是不想搞博文加密的，奈何博客地址不小心泄露给表妹，于是决定还是要折腾一下这个博文加密。&lt;/p&gt;
&lt;p&gt;（😎 ：表妹啊，</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>busuanzi&amp;live2d bug</title>
    <link href="http://example.com/2022/05/09/%E4%B8%8D%E8%92%9C%E5%AD%90&amp;%E7%9C%8B%E6%9D%BF%E5%96%B5bug/"/>
    <id>http://example.com/2022/05/09/%E4%B8%8D%E8%92%9C%E5%AD%90&amp;%E7%9C%8B%E6%9D%BF%E5%96%B5bug/</id>
    <published>2022-05-09T00:48:00.000Z</published>
    <updated>2022-05-24T05:10:34.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bug引入"><a href="#bug引入" class="headerlink" title="bug引入"></a>bug引入</h2><p> 在已经使用不蒜子插件实现流量统计的Hexo博客中对页面进一步美化时，加入live2d看板娘导致不蒜子失效。实践发现启动live2d插件功能时（即配置文件中<code>enable: true</code>），不蒜子失效，关闭插件（<code>enable: false</code>），不蒜子功能正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#看板喵</span><br><span class="line">live2d:</span><br><span class="line">  enable: true  #是否启用live2d</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  model: </span><br><span class="line">    use: live2d-widget-model-hijiki #模型选择</span><br><span class="line">  display: </span><br><span class="line">    position: left   </span><br><span class="line">    width: 140       </span><br><span class="line">    height: 280      </span><br><span class="line">  mobile: </span><br><span class="line">    show: false      </span><br></pre></td></tr></table></figure><h2 id="解决bug"><a href="#解决bug" class="headerlink" title="解决bug"></a>解决bug</h2><p>①：分别对不蒜子功能正常和非正常状态下的页面代码进行分析，发现不蒜子失效时的代码中显示<code>style=&quot;display: none;&quot;</code>，</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/(busuanzi&live2d)bug/14.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/><p>而关闭 live2d 插件后正常状态下是<code>style=&quot;display: inline;&quot;</code>，如下图：</p><img src='http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/(busuanzi&live2d)bug/15.png' align='center' style=' width:1888px; border:dashed 1px #008B8B; '/><p>②：查看自己添加的不蒜子代码，本人添加代码的位置为 <code>themes\cactus\layout\_partial\footer.ejs</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不蒜子统计访问量 --&gt;</span></span><br><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;       </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-pv&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-value&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-uv&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-user&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入不蒜子--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>在网页中直接打开我们引入的js，得到实现代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bszCaller,bszTag;!<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">var</span> c,d,e,a=!<span class="number">1</span>,b=[];ready=<span class="keyword">function</span>(<span class="params">c</span>)&#123;<span class="keyword">return</span> a||<span class="string">&quot;interactive&quot;</span>===<span class="variable language_">document</span>.<span class="property">readyState</span>||<span class="string">&quot;complete&quot;</span>===<span class="variable language_">document</span>.<span class="property">readyState</span>?c.<span class="title function_">call</span>(<span class="variable language_">document</span>):b.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> c.<span class="title function_">call</span>(<span class="variable language_">this</span>)&#125;),<span class="variable language_">this</span>&#125;,d=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=<span class="number">0</span>,c=b.<span class="property">length</span>;c&gt;a;a++)b[a].<span class="title function_">apply</span>(<span class="variable language_">document</span>);b=[]&#125;,e=<span class="keyword">function</span>(<span class="params"></span>)&#123;a||(a=!<span class="number">0</span>,d.<span class="title function_">call</span>(<span class="variable language_">window</span>),<span class="variable language_">document</span>.<span class="property">removeEventListener</span>?<span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>,e,!<span class="number">1</span>):<span class="variable language_">document</span>.<span class="property">attachEvent</span>&amp;&amp;(<span class="variable language_">document</span>.<span class="title function_">detachEvent</span>(<span class="string">&quot;onreadystatechange&quot;</span>,e),<span class="variable language_">window</span>==<span class="variable language_">window</span>.<span class="property">top</span>&amp;&amp;(<span class="built_in">clearInterval</span>(c),c=<span class="literal">null</span>)))&#125;,<span class="variable language_">document</span>.<span class="property">addEventListener</span>?<span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>,e,!<span class="number">1</span>):<span class="variable language_">document</span>.<span class="property">attachEvent</span>&amp;&amp;(<span class="variable language_">document</span>.<span class="title function_">attachEvent</span>(<span class="string">&quot;onreadystatechange&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="regexp">/loaded|complete/</span>.<span class="title function_">test</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>)&amp;&amp;<span class="title function_">e</span>()&#125;),<span class="variable language_">window</span>==<span class="variable language_">window</span>.<span class="property">top</span>&amp;&amp;(c=<span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">try</span>&#123;a||<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">doScroll</span>(<span class="string">&quot;left&quot;</span>)&#125;<span class="keyword">catch</span>(b)&#123;<span class="keyword">return</span>&#125;<span class="title function_">e</span>()&#125;,<span class="number">5</span>)))&#125;(),bszCaller=&#123;<span class="attr">fetch</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">var</span> c=<span class="string">&quot;BusuanziCallback_&quot;</span>+<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">1099511627776</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>());<span class="variable language_">window</span>[c]=<span class="variable language_">this</span>.evalCall(b),a=a.<span class="title function_">replace</span>(<span class="string">&quot;=BusuanziCallback&quot;</span>,<span class="string">&quot;=&quot;</span>+c),scriptTag=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;SCRIPT&quot;</span>),scriptTag.<span class="property">type</span>=<span class="string">&quot;text/javascript&quot;</span>,scriptTag.<span class="property">defer</span>=!<span class="number">0</span>,scriptTag.<span class="property">src</span>=a,scriptTag.<span class="property">referrerPolicy</span>=<span class="string">&quot;no-referrer-when-downgrade&quot;</span>,<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;HEAD&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(scriptTag)&#125;,<span class="attr">evalCall</span>:<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>)&#123;<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">try</span>&#123;<span class="title function_">a</span>(b),scriptTag.<span class="property">parentElement</span>.<span class="title function_">removeChild</span>(scriptTag)&#125;<span class="keyword">catch</span>(c)&#123;bszTag.<span class="title function_">hides</span>()&#125;&#125;)&#125;&#125;&#125;,bszCaller.<span class="title function_">fetch</span>(<span class="string">&quot;//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback&quot;</span>,<span class="keyword">function</span>(<span class="params">a</span>)&#123;bszTag.<span class="title function_">texts</span>(a),bszTag.<span class="title function_">shows</span>()&#125;),bszTag=&#123;<span class="attr">bszs</span>:[<span class="string">&quot;site_pv&quot;</span>,<span class="string">&quot;page_pv&quot;</span>,<span class="string">&quot;site_uv&quot;</span>],<span class="attr">texts</span>:<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">b</span>)&#123;<span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_value_&quot;</span>+b);c&amp;&amp;(c.<span class="property">innerHTML</span>=a[b])&#125;)&#125;,<span class="attr">hides</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="keyword">var</span> b=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_container_&quot;</span>+a);b&amp;&amp;(b.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;none&quot;</span>)&#125;)&#125;,<span class="attr">shows</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="keyword">var</span> b=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_container_&quot;</span>+a);b&amp;&amp;(b.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;inline&quot;</span>)&#125;)&#125;&#125;;</span><br></pre></td></tr></table></figure><p>③：而解决方法也很简单，首先是将不蒜子的js插件保存到本地。这个位置很重要，后面需要引入这个位置的js文件。</p><p>在我的主题中位于<code>\themes\cactus\source\lib\busuanzi\busuanzi.pure.mini.js</code>。</p><p>将js文件更改为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bszCaller,bszTag;!<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">var</span> c,d,e,a=!<span class="number">1</span>,b=[];ready=<span class="keyword">function</span>(<span class="params">c</span>)&#123;<span class="keyword">return</span> a||<span class="string">&quot;interactive&quot;</span>===<span class="variable language_">document</span>.<span class="property">readyState</span>||<span class="string">&quot;complete&quot;</span>===<span class="variable language_">document</span>.<span class="property">readyState</span>?c.<span class="title function_">call</span>(<span class="variable language_">document</span>):b.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> c.<span class="title function_">call</span>(<span class="variable language_">this</span>)&#125;),<span class="variable language_">this</span>&#125;,d=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=<span class="number">0</span>,c=b.<span class="property">length</span>;c&gt;a;a++)b[a].<span class="title function_">apply</span>(<span class="variable language_">document</span>);b=[]&#125;,e=<span class="keyword">function</span>(<span class="params"></span>)&#123;a||(a=!<span class="number">0</span>,d.<span class="title function_">call</span>(<span class="variable language_">window</span>),<span class="variable language_">document</span>.<span class="property">removeEventListener</span>?<span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>,e,!<span class="number">1</span>):<span class="variable language_">document</span>.<span class="property">attachEvent</span>&amp;&amp;(<span class="variable language_">document</span>.<span class="title function_">detachEvent</span>(<span class="string">&quot;onreadystatechange&quot;</span>,e),<span class="variable language_">window</span>==<span class="variable language_">window</span>.<span class="property">top</span>&amp;&amp;(<span class="built_in">clearInterval</span>(c),c=<span class="literal">null</span>)))&#125;,<span class="variable language_">document</span>.<span class="property">addEventListener</span>?<span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>,e,!<span class="number">1</span>):<span class="variable language_">document</span>.<span class="property">attachEvent</span>&amp;&amp;(<span class="variable language_">document</span>.<span class="title function_">attachEvent</span>(<span class="string">&quot;onreadystatechange&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="regexp">/loaded|complete/</span>.<span class="title function_">test</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>)&amp;&amp;<span class="title function_">e</span>()&#125;),<span class="variable language_">window</span>==<span class="variable language_">window</span>.<span class="property">top</span>&amp;&amp;(c=<span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">try</span>&#123;a||<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">doScroll</span>(<span class="string">&quot;left&quot;</span>)&#125;<span class="keyword">catch</span>(b)&#123;<span class="keyword">return</span>&#125;<span class="title function_">e</span>()&#125;,<span class="number">5</span>)))&#125;(),bszCaller=&#123;<span class="attr">fetch</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">var</span> c=<span class="string">&quot;BusuanziCallback_&quot;</span>+<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">1099511627776</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>());<span class="variable language_">window</span>[c]=<span class="variable language_">this</span>.evalCall(b),a=a.<span class="title function_">replace</span>(<span class="string">&quot;=BusuanziCallback&quot;</span>,<span class="string">&quot;=&quot;</span>+c),scriptTag=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;SCRIPT&quot;</span>),scriptTag.<span class="property">type</span>=<span class="string">&quot;text/javascript&quot;</span>,scriptTag.<span class="property">defer</span>=!<span class="number">0</span>,scriptTag.<span class="property">src</span>=a,<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;HEAD&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(scriptTag)&#125;,<span class="attr">evalCall</span>:<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>)&#123;<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">try</span>&#123;<span class="title function_">a</span>(b),scriptTag.<span class="property">parentElement</span>.<span class="title function_">removeChild</span>(scriptTag)&#125;<span class="keyword">catch</span>(c)&#123;bszTag.<span class="title function_">hides</span>()&#125;&#125;)&#125;&#125;&#125;,bszCaller.<span class="title function_">fetch</span>(<span class="string">&quot;//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback&quot;</span>,<span class="keyword">function</span>(<span class="params">a</span>)&#123;bszTag.<span class="title function_">texts</span>(a),bszTag.<span class="title function_">shows</span>()&#125;),bszTag=&#123;<span class="attr">bszs</span>:[<span class="string">&quot;site_pv&quot;</span>,<span class="string">&quot;page_pv&quot;</span>,<span class="string">&quot;site_uv&quot;</span>],<span class="attr">texts</span>:<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">b</span>)&#123;<span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_value_&quot;</span>+b);c&amp;&amp;(c.<span class="property">innerHTML</span>=a[b])&#125;)&#125;,<span class="attr">hides</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="keyword">var</span> b=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_container_&quot;</span>+a);b&amp;&amp;(b.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;&quot;</span>)&#125;)&#125;,<span class="attr">shows</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">a</span>)&#123;<span class="keyword">var</span> b=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_container_&quot;</span>+a);b&amp;&amp;(b.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;inline&quot;</span>)&#125;)&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作其实就是把其中的<b><code>b.style.display=&quot;none&quot;</code>中<code>none</code></b>去掉。</p><p>④：然后到 添加的不蒜子代码的位置 修改代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不蒜子统计访问量 --&gt;</span></span><br><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;       </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-pv&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-value&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-uv&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-user&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入不蒜子(路径修改为自己下载js的地址)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;/lib/busuanzi/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>⑤：可参考本人footer.ejs 全部代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer-left&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 网站运行时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>(); </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">createtime</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;05/06/2022 22:38:00&quot;</span>);<span class="comment">//建站时间 格式：月/日/年 时:分:秒</span></span></span><br><span class="line"><span class="language-javascript">                now.<span class="title function_">setTime</span>(now.<span class="title function_">getTime</span>()+<span class="number">250</span>); </span></span><br><span class="line"><span class="language-javascript">                days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(days); </span></span><br><span class="line"><span class="language-javascript">                hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hours); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(<span class="title class_">String</span>(hnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span></span><br><span class="line"><span class="language-javascript">                mnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(minutes); <span class="keyword">if</span>(<span class="title class_">String</span>(mnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125; </span></span><br><span class="line"><span class="language-javascript">                seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum); </span></span><br><span class="line"><span class="language-javascript">                snum = <span class="title class_">Math</span>.<span class="title function_">round</span>(seconds); <span class="keyword">if</span>(<span class="title class_">String</span>(snum).<span class="property">length</span> ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125; </span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;timeDate&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;has been running for &quot;</span>+dnum+<span class="string">&quot; d &quot;</span>; </span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;times&quot;</span>).<span class="property">innerHTML</span> = hnum + <span class="string">&quot; h &quot;</span> + mnum + <span class="string">&quot; m &quot;</span> + snum + <span class="string">&quot; s&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 版权年份 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          &lt;%= __(&#x27;footer.copyright&#x27;) %&gt; <span class="symbol">&amp;copy;</span></span><br><span class="line">          &lt;% var endYear = (theme.copyright &amp;&amp; theme.copyright.end_year) ? theme.copyright.end_year : new Date().getFullYear() %&gt;</span><br><span class="line">          &lt;% var startYear = (theme.copyright &amp;&amp; theme.copyright.start_year) ? theme.copyright.start_year : new Date().getFullYear() %&gt;</span><br><span class="line">          &lt;%= startYear &gt;= endYear ? endYear : startYear + &quot;-&quot; + endYear %&gt;</span><br><span class="line">          &lt;%= config.author || config.title %&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer-right&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 导航栏 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            &lt;% for (var i in theme.nav) &#123; %&gt;<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          --&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;</span>&gt;</span>&lt;%= __(&#x27;nav.&#x27;+i).replace(&quot;nav.&quot;, &quot;&quot;) %&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        --&gt;</span>&lt;% &#125; %&gt;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">          <span class="comment">&lt;!-- 不蒜子统计访问量 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            &lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;       </span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-pv&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-value&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-uv&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-user&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span>     </span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;/lib/busuanzi/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            &lt;% &#125; %&gt;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>问题解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bug引入&quot;&gt;&lt;a href=&quot;#bug引入&quot; class=&quot;headerlink&quot; title=&quot;bug引入&quot;&gt;&lt;/a&gt;bug引入&lt;/h2&gt;&lt;p&gt; 在已经使用不蒜子插件实现流量统计的Hexo博客中对页面进一步美化时，加入live2d看板娘导致不蒜子失效。实践发现</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Spring 八股文</title>
    <link href="http://example.com/2022/05/01/Spring-%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/05/01/Spring-%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-05-01T11:59:21.000Z</published>
    <updated>2022-06-04T11:12:00.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈Spring-的IOC"><a href="#谈谈Spring-的IOC" class="headerlink" title="谈谈Spring 的IOC"></a>谈谈Spring 的IOC</h2><p>①：Spring IOC 解决的是对象管理和对象依赖的问题。本来是我们自己手动new出来的对象，现在则把对象交给Spring的IOC容器管理。</p><p>②：IOC容器可以理解为一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系。等我们需要用对象的时候，从工厂里边获取就好了</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220604190611.png"/><h2 id="IOC的「控制反转」和「依赖注入」"><a href="#IOC的「控制反转」和「依赖注入」" class="headerlink" title="IOC的「控制反转」和「依赖注入」"></a>IOC的「控制反转」和「依赖注入」</h2><p>①：「控制反转」：把原有自己掌控的事交给别人去处理，它更多的是一种思想或者可以理解为设计模式，比如：本来由我们自己new出来的对象，现在交由IOC容器，把对象的控制权交给它方了</p><p>②：「依赖注入」：它其实是「控制反转」的实现方式，对象无需自行创建或者管理它的依赖关系，依赖关系将被「自动注入」到需要它们的对象当中去</p><h2 id="Spring-IOC优点"><a href="#Spring-IOC优点" class="headerlink" title="Spring IOC优点"></a>Spring IOC优点</h2><p>①：主要的好处在于「将对象集中统一管理」并且「降低耦合度」。</p><p>②：比如说：我用Spring IOC 可以方便单元测试、对象创建复杂、对象依赖复杂、单例等等的，什么都可以交给Spring IOC，理论上自己new出来的都可以解决上面的问题，Spring在各种场景组合下有可能不是最优解，但new出来的你要自己管理，可能你得自己写工厂，得实现一大套的东西才能满足需求，写着写着有可能还是Spring的那一套。如果项目里的对象都是就new下就完事了，没有多个实现类，那没事，不用Spring也没啥问题</p><p>③：并且Spring核心不仅仅IOC，除了把对象创建出来，还有一整套的Bean生命周期管理，比如说你要实现对象增强，就可以使用AOP不然你还得自己创建代理..</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220604190219.png"/><h2 id="谈谈Spring-的AOP"><a href="#谈谈Spring-的AOP" class="headerlink" title="谈谈Spring 的AOP"></a>谈谈Spring 的AOP</h2><p>①：Spring AOP 解决的是 非业务代码抽取的问题</p><p>②：AOP 底层的技术是动态代理，在Spring内实现依赖的是BeanPostProcessor</p><p>③：比如我们需要在方法上注入些「重复性」的非业务代码，就可以利用Spring AOP，所谓的「面向切面编程」在我理解下其实就是在方法前后增加非业务代码</p><h2 id="怎么把对象交给IOC容器管理"><a href="#怎么把对象交给IOC容器管理" class="headerlink" title="怎么把对象交给IOC容器管理"></a>怎么把对象交给IOC容器管理</h2><p>Spring提供了4种方式，分别是：</p><ul><li>注解：日常写业务代码一般用注解来定义各种对象</li><li>XML ：责任链这种一般配置在XML</li><li>JavaConfig：「注解」解决不了的就用JavaConfig</li><li>基于Groovy DSL配置</li></ul><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220604190249.png"/><h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><h2 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h2><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称。</li></ul><h2 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h2><ul><li><b>singleton</b> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li><li><b>prototype</b> : 每次请求都会创建一个新的 bean 实例。</li><li><b>request</b>: 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><b>session</b>: 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><b>global-session</b>： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;谈谈Spring-的IOC&quot;&gt;&lt;a href=&quot;#谈谈Spring-的IOC&quot; class=&quot;headerlink&quot; title=&quot;谈谈Spring 的IOC&quot;&gt;&lt;/a&gt;谈谈Spring 的IOC&lt;/h2&gt;&lt;p&gt;①：Spring IOC 解决的是对象管理和对象依赖</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>CMS&amp;G1八股文</title>
    <link href="http://example.com/2022/04/30/CMS&amp;G1-%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/04/30/CMS&amp;G1-%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-04-30T10:29:31.000Z</published>
    <updated>2022-06-02T12:06:19.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial  收集器"></a>Serial  收集器</h2><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183341.png"></img></p><p>①：是单线程回收器，历史最悠久</p><p>②：工作时会 “Stop The World” </p><p>③：新生代采用 标记 - 复制 算法，老年代采用 标记 - 整理算法</p><p>④：简单高效，有较高单线程收集效率，对于运行在 Client 模式下的虚拟机而言是个不错的选择</p><p>⑤：能够与 CMS 垃圾收集器配合使用</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew  收集器"></a>ParNew  收集器</h2><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183402.png"></img></p><p>①：Serical 的多线程版本</p><p>②：新生代采用 标记 - 复制 算法，老年代采用 标记 - 整理算法</p><p>③：默认开始线程数与CPU核数相同</p><p>④：能够与 CMS 垃圾收集器配合使用</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge  收集器"></a>Parallel Scavenge  收集器</h2><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183426.png"></img></p><p>①：关注点是系统吞吐量（代码运行时间 &#x2F; CPU总耗时时间）和高效利用 CPU，而 CMS 等垃圾收集器更多关注的是用户停顿时间（用户体验）</p><p>②：新生代采用 标记 - 复制 算法，老年代采用 标记 - 整理算法</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>①：Serial 垃圾收集器的老年代版本</p><p>②：使用 标记 - 整理 算法</p><p>②：作为CMS 垃圾收集器的后备方案</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old  收集器"></a>Parallel Old  收集器</h2><p>①：Parallel Scavenge 收集器的老年代版本</p><p>②：使用多线程和 标记 - 整理 算法</p><p>③：作为CMS 垃圾收集器的后备方案</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS  收集器"></a>CMS  收集器</h2><p>①：CMS(Concurrent Mark Sweep)「并发标记清除」以获取最短回收停顿时间为目标，注重用户体验，是老年代的收集器</p><p>②：HotSpot 虚拟机第一款真正意义上的并发收集器，一定程度上实现了用户线程和垃圾回收线程的同时工作</p><p>③：使用 标记 - 清除 算法</p><p>④：回收过程：初始标记、并发标记、并发预处理、重新标记以及并发清除</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183449.png"/><ol><li>初始标记：标记GCRoots「直接关联」的对象以及「年轻代」指向「老年代」的对象（Stop The World），速度很快</li><li>并发标记：同时开启 GC 和用户线程。这一阶段主要是从GC Roots向下「追溯」，标记所有可达的对象。比较耗费时间的（需要追溯）</li><li>并发预处理：目的是减少下一个阶段「重新标记」所消耗的时间<ul><li>「并发标记」这个阶段由于用户线程是没有被挂起的，所以对象是有可能发生变化的。 可能有些对象，从新生代晋升到了老年代；也可能有些对象，直接分配到了老年代（大对象）；也可能老年代或者新生代的对象引用发生了变化…</li><li>针对老年代的对象，可以借助card table的存储（将老年代对象发生变化所对应的卡页标记为dirty）。所以「并发预处理」这个阶段会扫描可能由于「并发标记」时导致老年代发生变化的对象，会再扫描一遍标记为dirty的卡页。对于新生代的对象，我们还是得遍历新生代来看看在「并发标记」过程中有没有对象引用了老年代。不过JVM里给我们提供了很多「参数」，有可能在这个过程中会触发一次 Minor GC（触发了Minor GC 是意味着就可以更少地遍历新生代的对象）</li></ul></li><li>重新标记（Stop The World）：这个过程的停顿时间其实很大程度上取决于上面「并发预处理」阶段，重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除：不会Stop The World。一边用户线程在执行，一边GC线程在回收不可达的对象。这个过程，还是有可能用户线程在不断产生垃圾，但只能留到下一次GC 进行处理了，产生的这些垃圾被叫做 “浮动垃圾” 。</li></ol><p>⑤：主要优点：并发收集、低停顿</p><p>⑥：主要缺点</p><ol><li>空间需要预留：CMS垃圾收集器可以一边回收垃圾，一边处理用户线程，那在这个过程中需要保证有充足的内存空间供用户使用。如果CMS运行过程中预留的空间不够用了，就会报错，这时会启动 Serial Old垃圾收集器进行老年代的垃圾回收，会导致停顿的时间很长。当然空间预留多少也是有参数配置的</li><li>内存碎片问题：CMS本质上是实现了「标记清除算法」的收集器，这会意味着会产生内存碎片。由于碎片太多，又可能会导致内存空间不足所触发Full GC，CMS一般会在触发Full GC这个过程对碎片进行整理。整理涉及到「移动」或「标记」，那这个过程肯定会Stop The World的，如果内存足够大，那这个过程卡顿也是需要一定的时间的。</li></ol><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>①：面向服务器，针对大容量内存的机器</p><p>②：满足GC停顿时间要求的同时，还具备高吞吐量性能</p><p>③：整体看采用 “标记 - 整理” 算法，局部看采用 “标记 - 复制” 算法</p><p>④：新生代（Eden、S1、S0），老年代（Old）等不再按照物理划分，而是按照逻辑划分。将堆内存「逻辑」划分为多个Region，增添了Humongous（大对象区域），其实就是用来存储特别大的对象（大于Region内存的一半），一旦发现没有引用指向大对象，就可直接在年轻代的Minor GC中被回收掉。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183521.png" alt="img" style="zoom: 50%;" /><p>⑤：为什么要将「堆空间」进行「细分」多个小的区域？</p><p>如果堆空间（内存）大的时候，每次进行「垃圾回收」都需要对一整块大的区域进行回收，那收集的时间是不好控制的，而划分多个小区域之后，那对这些「小区域」回收就容易控制它的「收集时间」了。</p><p>⑥：Minor GC：</p><ol><li>等到Eden区满了之后，会触发Minor GC（Stop The World）</li><li>在G1的世界里，新生代和老年代所占堆的空间是没那么固定的（会动态根据「最大停顿时间」进行调整），这块要知道会给我们提供参数进行配置就好了，所以，动态地改变年轻代Region的个数可以「控制」Minor GC的开销</li><li>分为三个步骤：根扫描、更新&amp;&amp;处理 RSet、复制对象<ol><li>根扫描：会 “Stop The World”，记录下直接与 root 相连的对象，速度很快 </li><li>更新&amp;&amp;处理RSet：<ul><li>涉及到「Rset」的概念：在CMS中，因为Minor GC 是回收年轻代的对象，但如果老年代有对象引用着年轻代，那这些被老年代引用的对象也不能回收掉。同样的，在G1也有这种问题（毕竟是Minor GC）。CMS使用的是卡表，而G1解决「跨代引用」的问题的存储一般叫做RSet，RSet这种存储在每个Region都会有，它记录着「其他Region引用了当前Region的对象关系」</li><li>对于年轻代的Region，它的RSet 只保存了来自老年代的引用（因为年轻代的没必要存储，自己都要做Minor GC了）</li><li>而对于老年代的 Region 来说，它的 RSet 也只会保存老年代对它的引用（在G1垃圾收集器，老年代回收之前，都会先对年轻代进行回收，所以没必要保存年轻代的引用）</li><li>所以第二步主要做的事情：处理RSet的信息并且扫描，将老年代对象持有年轻代对象的相关引用都加入到GC Roots下，避免被回收掉</li></ul></li><li>复制对象：把扫描之后存活的对象往「空的Survivor区」或者「老年代」存放，其他的Eden区进行清除<ul><li>这里要提下的是，在G1还有另一个名词，叫做CSet(Collection Set)。它保存了一次GC中「将执行垃圾回收」的Region。CSet中的所有存活对象都会被转移到别的可用Region上。在Minor GC 的最后，会处理下软引用、弱引用等引用，结束收集</li></ul></li></ol></li></ol><p>⑦：Mixed GC：</p><ol><li>当堆空间的占用率达到一定阈值后会触发Mixed GC（默认45%，由参数决定）</li><li>Mixed GC 依赖「全局并发标记」统计后的Region数据，「全局并发标记」它的过程跟CMS非常类型</li><li>步骤大概是：初始标记（STW）、并发标记、最终标记（STW）以及清理（STW）<ol><li>初始标记：这个过程是「共用」了Minor GC的 Stop The World（Mixed GC 一定会发生 Minor GC），复用了「扫描GC Roots」的操作。在这个过程中，老年代和新生代都会扫，总的来说，「初始标记」这个过程还是比较快的，毕竟没有追溯遍历嘛</li><li>并发标记：这个阶段不会Stop The World，GC线程与用户线程一起执行，GC线程负责收集各个 Region 的存活对象信息。从GC Roots往下追溯，查找整个堆存活的对象，比较耗时<ul><li>在G1中解决「并发标记」阶段导致引用变更的问题，使用的是SATB算法。可以简单理解为：在GC 开始的时候，它为存活的对象做了一次「快照」，在「并发阶段」时，把每一次发生引用关系变化时旧的引用值给记下来，然后在「重新标记」阶段只扫描着块「发生过变化」的引用，看有没有对象还是存活的，加入到「GC Roots」上，不过SATB算法有个小的问题，就是：如果在开始时，G1就认为它是活的，那就在此次GC中不会对它回收，即便可能在「并发阶段」上对象已经变为了垃圾。所以，G1也有可能会存在「浮动垃圾」的问题，但是总的来说，对于G1而言，问题不大（毕竟它不是追求一次把所有的垃圾都清除掉，而是注重 Stop The World时间）</li></ul></li><li>最终标记：跟CMS又一样，标记那些在「并发标记」阶段发生变化的对象</li><li>清理：这个阶段也是会Stop The World的，主要清点和重置标记状态。会根据「停顿预测模型」（其实就是设定的停顿时间），来决定本次GC回收多少Region。一般来说，Mixed GC会选定所有的年轻代Region，部分「回收价值高」的老年代Region（回收价值高其实就是垃圾多）进行采集。最后Mixed GC 进行清除还是通过「拷贝」的方式去干的。所以，一次回收未必是将所有的垃圾进行回收的，G1会依据停顿时间做出选择Region数量</li></ol></li></ol><p>⑧：Full GC：如果在Mixed GC中无法跟上用户线程分配内存的速度，导致老年代填满无法继续进行Mixed GC，就又会降级到Serial Old GC来收集整个GC heap。不过这个场景相较于CMS还是很少的，毕竟G1没有CMS内存碎片这种问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">JVM 垃圾回收详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/431042318">稳了！我准备了1个晚上的CMS垃圾收集器</a></p><p><a href="https://zhuanlan.zhihu.com/p/431908205">什么？面试官问我G1垃圾收集器？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Serial-收集器&quot;&gt;&lt;a href=&quot;#Serial-收集器&quot; class=&quot;headerlink&quot; title=&quot;Serial  收集器&quot;&gt;&lt;/a&gt;Serial  收集器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://fastly.jsdelivr.net</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Map八股文</title>
    <link href="http://example.com/2022/04/15/Map%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/04/15/Map%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-04-15T06:51:27.000Z</published>
    <updated>2022-06-03T13:56:50.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485434&idx=1&sn=00e572dac41f3bbbdca68c0f5d1c77b1&scene=21#wechat_redirect">《对线面试官》 Map集合</a>，方便查阅记忆整理出来的。</p><h2 id="讲一讲Map（Jdk8）"><a href="#讲一讲Map（Jdk8）" class="headerlink" title="讲一讲Map（Jdk8）"></a>讲一讲Map（Jdk8）</h2><p>Map在Java里边是一个接口，常见的实现类有 HashMap、LinkedHashMap、TreeMap 和 ConcurrentHashMap。哈希表的结构是 数组 + 链表 的方式。</p><ul><li>HashMap 底层数据结构是数组+链表&#x2F;红黑树。</li><li>LinkedHashMap 底层数据结构是数组+链表&#x2F;红黑树+双向链表。</li><li>TreeMap 底层数据结构是红黑树。</li><li>而 ConcurrentHashMap 底层数据结构也是数组+链表&#x2F;红黑树</li></ul><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603100753.png"/><h2 id="创建HashMap时会发生什么"><a href="#创建HashMap时会发生什么" class="headerlink" title="创建HashMap时会发生什么"></a>创建HashMap时会发生什么</h2><p>①：HashMap有几个构造方法，但最主要的就是指定初始值大小和负载因子的大小。如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75。</p><p>②：HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。</p><p>③：我们把元素放进HashMap的时候，需要算出这个元素所在的位置（hash）。在HashMap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。为什么HashMap的大小只能是2次幂，因为只有大小为2次幂时，才能合理用位运算替代取模。而负载因子的大小决定着哈希表的扩容和哈希冲突。比如现在我默认的HashMap大小为16，负载因子为0.75，这意味着数组最多只能放12个元素，一旦超过12个元素，则哈希表需要扩容。怎么算出是12呢？很简单，就是16*0.75。每次put元素进去的时候，都会检查HashMap的大小有没有超过这个阈值，如果有，则需要扩容。</p><p>④：鉴于上面的说法（HashMap的大小只能是2次幂），所以扩容的时候时候默认是扩原来的2倍。扩容这个操作肯定是耗时的，那能不能把负载因子调高一点，比如我要调至为1，那我的HashMap就等到16个元素的时候才扩容呢。是可以的，但是不推荐。负载因子调高了，这意味着哈希冲突的概率会增高，哈希冲突概率增高，同样会耗时（因为查找的速度变慢了）。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603100933.png"/><h2 id="put元素的时候，传递的Key如何计算哈希值"><a href="#put元素的时候，传递的Key如何计算哈希值" class="headerlink" title="put元素的时候，传递的Key如何计算哈希值"></a>put元素的时候，传递的Key如何计算哈希值</h2><p>实现就在hash方法上，可以发现的是，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。这样做的好处可以增加了随机性，减少了碰撞冲突的可能性。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/E44aHibktsKaOQSs0icAVN0a9uQZeSYzKSmpLk56ibGp8M2prj0iaTXbx0Mn83ic5t5pdEHBD8GKe6f3icGevgnMn81Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603110421.png"/><h2 id="put-和-get-方法的实现"><a href="#put-和-get-方法的实现" class="headerlink" title="put() 和 get() 方法的实现"></a>put() 和 get() 方法的实现</h2><p>①：在 put() 的时候，首先对 key 做 hash运算，计算出该 key 所在的 index。</p><p>②：如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。假设key是相同的，则替换到原来的值。最后判断哈希表是否满了(当前哈希表大小*负载因子），如果满了，则扩容。</p><p>③：在 get() 的时候，还是对 key 做 hash运算，计算出该key所在的index，然后判断是否有 hash冲突。假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603110446.png" style="zoom:67%;" /><h2 id="HashMap怎么判断一个元素是否相同"><a href="#HashMap怎么判断一个元素是否相同" class="headerlink" title="HashMap怎么判断一个元素是否相同"></a>HashMap怎么判断一个元素是否相同</h2><p>首先会比较hash值，随后会用 &#x3D;&#x3D;运算符 和 equals() 来判断该元素是否相同。说白了就是：如果只有hash值相同，那说明该元素哈希冲突了，如果 hash值和 equals() 都相同，那说明该元素是同一个。</p><h2 id="HashMap-什么情况下用到红黑树"><a href="#HashMap-什么情况下用到红黑树" class="headerlink" title="HashMap 什么情况下用到红黑树"></a>HashMap 什么情况下用到红黑树</h2><p>当数组的大小大于64 且 链表的大小大于8 的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量。链表查询时间复杂度O(N)，插入时间复杂度O(1)，红黑树查询和插入时间复杂度O(logN)</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603110518.png"/><h2 id="日常开发中-LinkedHashMap-用的多吗"><a href="#日常开发中-LinkedHashMap-用的多吗" class="headerlink" title="日常开发中 LinkedHashMap 用的多吗"></a>日常开发中 LinkedHashMap 用的多吗</h2><p>①：其实在日常开发中 LinkedHashMap 用得不多。</p><p>②：在前面也提到了，LinkedHashMap底层结构是数组+链表+双向链表，实际上它继承了HashMap，在HashMap的基础上维护了一个双向链表。有了这个双向链表，我们的插入可以是有序的，这里的有序不是指大小有序，而是插入有序。</p><p>③：LinkedHashMap 在遍历的时候实际用的是双向链表来遍历的，所以 LinkedHashMap 的大小不会影响到遍历的性能</p><h2 id="日常开发中-TreeMap-用的多吗"><a href="#日常开发中-TreeMap-用的多吗" class="headerlink" title="日常开发中 TreeMap 用的多吗"></a>日常开发中 TreeMap 用的多吗</h2><p>①：TreeMap 在现实开发中用得也不多，TreeMap的底层数据结构是红黑树。</p><p>②：TreeMap 的 key不能为 null（如果为null，那还怎么排序呢），TreeMap有序是通过 Comparator 来进行比较的，如果 comparator为null，那么就使用自然顺序</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603110550.png"/><h2 id="线程安全的Map"><a href="#线程安全的Map" class="headerlink" title="线程安全的Map"></a>线程安全的Map</h2><p>①：HashMap不是线程安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如说：线程Aput进去了，线程Bget不出来。</p><p>②：我们想要线程安全，可以使用ConcurrentHashMap。ConcurrentHashMap是线程安全的Map实现类，它在juc包下的。</p><p>③：线程安全的Map实现类除了ConcurrentHashMap还有一个叫做Hashtable。</p><p>④：当然了，也可以使用Collections来包装出一个线程安全的Map。但无论是Hashtable还是Collections包装出来的都比较低效（因为是直接在外层套synchronize），所以我们一般有线程安全问题考量的，都使用ConcurrentHashMap</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603110625.png"/><p>⑤：ConcurrentHashMap 的底层数据结构是 数组+链表&#x2F;红黑树，它能支持高并发的访问和更新，是线程安全的。ConcurrentHashMap 通过在部分加锁 和 利用CAS算法来实现同步，在get的时候没有加锁，Node用了 volatile 给修饰。在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁</p><h2 id="JDK-7-和JDK8中HashMap的区别"><a href="#JDK-7-和JDK8中HashMap的区别" class="headerlink" title="JDK 7 和JDK8中HashMap的区别"></a>JDK 7 和JDK8中HashMap的区别</h2><p><img src="C:\Users\18375\AppData\Roaming\Typora\typora-user-images\image-20220603112210655.png" alt="image-20220603112210655"></p><h2 id="JDK-7-和JDK8中-ConcurrentHashMap-的区别"><a href="#JDK-7-和JDK8中-ConcurrentHashMap-的区别" class="headerlink" title="JDK 7 和JDK8中 ConcurrentHashMap 的区别"></a>JDK 7 和JDK8中 ConcurrentHashMap 的区别</h2><p><img src="C:\Users\18375\AppData\Roaming\Typora\typora-user-images\image-20220603112238976.png" alt="image-20220603112238976"></p><p><img src="C:\Users\18375\AppData\Roaming\Typora\typora-user-images\image-20220603112246489.png" alt="image-20220603112246489"></p><p><img src="C:\Users\18375\AppData\Roaming\Typora\typora-user-images\image-20220603112254987.png" alt="image-20220603112254987"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5M</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>List八股文</title>
    <link href="http://example.com/2022/04/14/List%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/04/14/List%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-04-13T20:29:13.000Z</published>
    <updated>2022-06-03T02:04:13.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考<a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247485417&idx=1&sn=eece302f9a581139a3ad3befc61773c0&scene=21#wechat_redirect">《对线面试官》 List集合</a>，方便查阅记忆整理出来的。</p><h2 id="讲一讲-List"><a href="#讲一讲-List" class="headerlink" title="讲一讲 List"></a>讲一讲 List</h2><p>①：List在Java里边是一个接口，常见的实现类有 ArrayList 和 LinkedList，在开发中用得最多的是ArrayList</p><p>②：ArrayList的底层数据结构是数组，LinkedList底层数据结构是链表。</p><h2 id="ArrayList-和-Array"><a href="#ArrayList-和-Array" class="headerlink" title="ArrayList 和 Array"></a>ArrayList 和 Array</h2><p>①：原生的数组会有一个特点：你在使用的时候必须要为它创建大小，而ArrayList不用。</p><p>②：在日常开发的时候，往往我们是不知道数组的大小的。如果数组的大小指定多了，内存浪费；如果数组大小指定少了，装不下。假设我们给定数组的大小是10，要往这个数组里边填充元素，我们只能添加10个元素。</p><p>③：而ArrayList实现了动态扩容，我们在使用ArrayList的时候可以往里边添加20个，30个，甚至更多的元素</p><p>④：当我们 <code>new ArrayList()</code> 的时候，默认会有一个空的Object数组，大小为0。当我们第一次add添加数据的时候，会给这个数组初始化一个大小，这个大小默认值为10使用ArrayList在每一次add的时候，它都会先去计算这个数组够不够空间。如果空间是够的，那直接追加上去就好了。如果不够，那就得扩容</p><h2 id="ArrayList-的扩容"><a href="#ArrayList-的扩容" class="headerlink" title="ArrayList 的扩容"></a>ArrayList 的扩容</h2><p>在源码里边，有个grow方法，每一次扩原来的1.5倍。比如说，初始化的值是10。现在我第11个元素要进来了，发现这个数组的空间不够了，所以会扩到15。空间扩完容之后，会调用 <code>arraycopy()</code> 来对数组进行拷贝</p><h2 id="为什么日常开发中用得最多的是ArrayList"><a href="#为什么日常开发中用得最多的是ArrayList" class="headerlink" title="为什么日常开发中用得最多的是ArrayList"></a>为什么日常开发中用得最多的是ArrayList</h2><p>①：是由底层的数据结构来决定的，在日常开发中，遍历的需求比增删要多，即便是增删也是往往在List的尾部添加就OK了。像在尾部添加元素，ArrayList的时间复杂度也就O(1)</p><p>②：另外的是，ArrayList的增删底层调用的copyOf()被优化过，现代CPU对内存可以块操作，ArrayList 的增删一点儿也不会比 LinkedList慢</p><h2 id="说一说Vector"><a href="#说一说Vector" class="headerlink" title="说一说Vector"></a>说一说Vector</h2><p>①：Vector 底层结构是数组，一般现在我们已经很少用了。</p><p>②：相对于ArrayList，它是线程安全的，在扩容的时候它是直接扩容两倍的。比如现在有10个元素，要扩容的时候，就会将数组的大小增长到20</p><h2 id="copy-on-write-机制"><a href="#copy-on-write-机制" class="headerlink" title="copy-on-write 机制"></a>copy-on-write 机制</h2><p>①：在Linux中，我们知道所有的进程都是 init 进程 fork 出来的，除了进程号之外，fork出来的进程，默认跟父进程一模一样的。</p><p>②：当使用了cow机制，子进程在被fork之后exec之前，两个进程用的是相同的内存空间的，这意味着子进程的代码段、数据段、堆栈都是指向父进程的物理空间，当父子进程中有更改的行为发生时，再为子进程分配相应物理空间。这样做的好处就是，等到真正发生修改的时候，才去分配资源，可以减少分配或者复制大量资源时带来的瞬间延时。</p><p>③：简单来说，就可以理解为我们的懒加载，或者说单例模式的懒汉式。等真正用到的时候再分配</p><p>④：在文件系统中，其实也有cow的机制。文件系统的cow就是在修改数据的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改。比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。如果这时候断电了，原来A的内容还在。这样做的好处就是可以保证数据的完整性，瞬间挂掉了容易恢复。</p><h2 id="线程安全的-List"><a href="#线程安全的-List" class="headerlink" title="线程安全的 List"></a>线程安全的 List</h2><p>①：首先，我们也可以用Collections来将ArrayList来包装一下，变成线程安全。</p><p>②：在 <code>java.util.concurrent</code> 包下还有一个类，叫做 CopyOnWriteArrayList</p><p>③：CopyOnWriteArrayList 是一个线程安全的List，底层是通过复制数组的方式来实现的。我来说说它的 <code>add()</code> 方法的实现吧，在 <code>add()</code> 方法其实他会加 lock锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把 array 的指向改变为新的数组。<code>get()</code> 方法又或是 <code>size()</code> 方法只是获取 array 所指向的数组的元素或者大小。读不加锁，写加锁</p><p>④：可以发现的是，CopyOnWriteArrayList 跟文件系统的COW机制是很像的</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/bagu/20220603100137.png"/><h2 id="CopyOnWriteArrayList-缺点吗"><a href="#CopyOnWriteArrayList-缺点吗" class="headerlink" title="CopyOnWriteArrayList 缺点吗"></a>CopyOnWriteArrayList 缺点吗</h2><p>①：很显然，CopyOnWriteArrayList 是很耗费内存的，每次 <code>set()/add()</code> 都会复制一个数组出来</p><p>②：另外就是CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性。假设两个线程，线程A去读取CopyOnWriteArrayList的数据，还没读完，现在线程B把这个List给清空了，线程A此时还是可以把剩余的数据给读出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5M</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Rpc巩固</title>
    <link href="http://example.com/2022/03/22/Rpc%E5%B7%A9%E5%9B%BA/"/>
    <id>http://example.com/2022/03/22/Rpc%E5%B7%A9%E5%9B%BA/</id>
    <published>2022-03-21T16:00:00.000Z</published>
    <updated>2022-05-24T03:31:39.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-RPC简介"><a href="#1-RPC简介" class="headerlink" title="1.RPC简介"></a>1.RPC简介</h2><p>RPC（Remote Procedure Call）远程调用协议。RPC协议规定允许互联网中一台主机调用另一台主机的程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调<b>当A程序调用B程序中的功能或方法时，A是不知道B中方法的实现的</b>。</p><p>RPC是上层协议，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上来讲只要是满足网络中进行通讯调用的都统称为RPC，甚至基于HTTP协议都可以说是RPC的具体实现，但是具体分析来看RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。</p><p>RPC协议是基于分布式架构而出现的，所以RPC在分布式项目中有得天独厚的优势。</p><h2 id="2-RPC和HTTP对比"><a href="#2-RPC和HTTP对比" class="headerlink" title="2.RPC和HTTP对比"></a>2.RPC和HTTP对比</h2><h3 id="2-1具体实现"><a href="#2-1具体实现" class="headerlink" title="2.1具体实现"></a>2.1具体实现</h3><p>RPC：可以基于TCP协议，也可以基于HTTP协议。（传输层 + 应用层）</p><p>HTTP：基于HTTP协议。（应用层）</p><h3 id="2-2效率"><a href="#2-2效率" class="headerlink" title="2.2效率"></a>2.2效率</h3><p>RPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。</p><p>HTTP：如果是HTTP1.1 报文中内容固定，传递的报文对于客户端而言有些是无用的。如果是HTTP2.0 以后的版本和RPC相差不大，比RPC少的可能就是一些服务治理等功能。</p><h3 id="2-3连接方式"><a href="#2-3连接方式" class="headerlink" title="2.3连接方式"></a>2.3连接方式</h3><p>RPC：长连接支持</p><p>HTTP：前期不支持长连接，每次建立连接都需要3次握手，断开连接需要4次挥手。HTTP2.0后增加了连接池，可以支持长连接。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc/rpc1.png"></img></p><h3 id="2-4性能"><a href="#2-4性能" class="headerlink" title="2.4性能"></a>2.4性能</h3><p>RPC：可以基于很多序列化方式（可以支持字节，也可以支持文本）</p><p>HTTP：主要是通过JSON，序列化和反序列化效率更低（超文本传输协议，支持文本）</p><h3 id="2-5注册中心"><a href="#2-5注册中心" class="headerlink" title="2.5注册中心"></a>2.5注册中心</h3><p>RPC：一般RPC框架都带有注册中心</p><p>HTTP：直接连接</p><h3 id="2-6负载均衡"><a href="#2-6负载均衡" class="headerlink" title="2.6负载均衡"></a>2.6负载均衡</h3><p>RPC：绝大多数RPC框架都带有负载均衡</p><p>HTTP：一般都需要第三方工具。如：nginx</p><h3 id="2-7总结"><a href="#2-7总结" class="headerlink" title="2.7总结"></a>2.7总结</h3><p>RPC框架一般都带有丰富的服务治理等功能，更适合企业内部接口调用。而HTTP更适合多平台之间互相调用。例如：某人在京东秒杀商品，采用的是HTTP协议；而点击秒杀按钮后，京东内部采用的是RPC协议，我们并不了解秒杀按钮的具体做了什么。</p><h2 id="3-HttpClient实现RPC"><a href="#3-HttpClient实现RPC" class="headerlink" title="3.HttpClient实现RPC"></a>3.HttpClient实现RPC</h2><h3 id="3-1HttpClient简介"><a href="#3-1HttpClient简介" class="headerlink" title="3.1HttpClient简介"></a>3.1HttpClient简介</h3><p>在JDK中java.net包下提供了用户HTTP访问的基本功能，但是它缺少灵活性或许多应用所缺少的功能。我们可以使用基于Http协议的HttpClient（来自Apache）来实现使用Java代码完成标准HTTP请求以及响应；支持池化（长连接）</p><h3 id="3-2模拟实现"><a href="#3-2模拟实现" class="headerlink" title="3.2模拟实现"></a>3.2模拟实现</h3><h4 id="3-2-1无参数Get请求模拟"><a href="#3-2-1无参数Get请求模拟" class="headerlink" title="3.2.1无参数Get请求模拟"></a>3.2.1无参数Get请求模拟</h4><p>客户端（浏览器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无参数的GET请求*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGetWithoutParams</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"><span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost:8080/test&quot;</span>);<span class="comment">//声明get请求</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(get);<span class="comment">//发起请求并接受结果</span></span><br><span class="line"><span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();<span class="comment">//获取响应体。响应数据是个基于HTTP协议标准字符串封装的对象，可能有乱码问题。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">responseString</span> <span class="operator">=</span> EntityUtils.toString(entity,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//通过Http实体工具类，采取&quot;UTF-8&quot;格式转换响应体数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;服务器响应数据是 - [&quot;</span> + responseString + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    client.close();<span class="comment">//关闭客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test&quot;,produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;msg\&quot;:\&quot;处理返回\&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2带参数Get请求模拟"><a href="#3-2-2带参数Get请求模拟" class="headerlink" title="3.2.2带参数Get请求模拟"></a>3.2.2带参数Get请求模拟</h4><p>客户端（浏览器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有参数的GET请求*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGetWithParams</span><span class="params">()</span> <span class="keyword">throws</span> URIException&#123;</span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">    <span class="comment">/*URI的构建分是否使用?携带参数，以下为不使用?携带参数的方式*/</span></span><br><span class="line">    <span class="comment">//可以使用URIBuilder类来构建；或者使用HttpGet（参考无参数Get请求模拟），下面使用URIBuilder类</span></span><br><span class="line">    <span class="type">URIBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URIBuilder</span>(<span class="string">&quot;http://localhost:8080/params&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*参数传递分为单参数传递和多参数传递，二选一即可*/</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//基于单参数传递</span></span><br><span class="line">    <span class="comment">/*buildr.addParameter(&quot;name&quot;,&quot;soul&quot;);</span></span><br><span class="line"><span class="comment">    buildr.addParameter(&quot;password&quot;,&quot;123&quot;);</span></span><br><span class="line"><span class="comment">    URI uri = builder.build();*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//基于多参数传递</span></span><br><span class="line">    List&lt;NameValuePair&gt; nvps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    nvps.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;soul&quot;</span>));</span><br><span class="line">    nvps.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    builder.addParameters(nvps);</span><br><span class="line">    <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> builder.build();</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">responseString</span> <span class="operator">=</span> EntityUtils.toString(client.execute(<span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri)).getEntity(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器响应数据是 - [&quot;</span> + responseString + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/params&quot;,produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">params</span><span class="params">(String name, String password)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name - &quot;</span> + name + <span class="string">&quot;; password - &quot;</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;msg\&quot;:\&quot;登录成功\&quot;,\&quot;user\&quot;:&#123;\&quot;name\&quot;:\&quot;&quot;</span>+name+<span class="string">&quot;\&quot;,\&quot;password\&quot;:\&quot;&quot;</span>+password+<span class="string">&quot;\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3无参数Post请求模拟"><a href="#3-2-3无参数Post请求模拟" class="headerlink" title="3.2.3无参数Post请求模拟"></a>3.2.3无参数Post请求模拟</h4><p>客户端（浏览器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无参数的POST请求*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPostWithParams</span><span class="params">()</span> <span class="keyword">throws</span> URIException&#123;</span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">    <span class="type">HttpPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8080/test&quot;</span>);</span><br><span class="line">    <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(get);</span><br><span class="line">    <span class="type">String</span> <span class="variable">responseString</span> <span class="operator">=</span> EntityUtils.toString(client.execute(<span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri)).getEntity(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器响应数据是 - [&quot;</span> + responseString + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test&quot;,produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;msg\&quot;:\&quot;处理返回\&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4带参数Post请求模拟"><a href="#3-2-4带参数Post请求模拟" class="headerlink" title="3.2.4带参数Post请求模拟"></a>3.2.4带参数Post请求模拟</h4><p>客户端（浏览器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有参数的POST请求*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPostWithParams</span><span class="params">()</span> <span class="keyword">throws</span> URIException&#123;</span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*方式1:使用请求头传递参数*/</span></span><br><span class="line">    <span class="comment">/*URI的构建分是否使用?携带参数，以下为使用?携带参数的方式*/</span></span><br><span class="line">    <span class="type">URIBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URIBuilder</span>(<span class="string">&quot;http://localhost:8080/params?name=soul&amp;password=123&quot;</span>);</span><br><span class="line">    <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> builder.build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*方式2:使用请求体传递（对象）参数*/</span></span><br><span class="line">    <span class="type">HttpPost</span> <span class="variable">bodyParamsPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8080/params&quot;</span>);</span><br><span class="line">    <span class="comment">//定义请求协议体，设置请求参数。使用请求体需要定义请求体格式，默认是表单格式</span></span><br><span class="line">    <span class="comment">//使用URIBuilder对象构建的URI对象，就是请求体传递参数的</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(user);<span class="comment">//这里使用了FastJson</span></span><br><span class="line">    <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonString, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    bodyParamsPost.setEntity(entity);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">responseString</span> <span class="operator">=</span> EntityUtils.toString(client.execute(<span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri)).getEntity(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器响应数据是 - [&quot;</span> + responseString + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/params&quot;,produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">params</span><span class="params">(String name, String password)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name - &quot;</span> + name + <span class="string">&quot;; password - &quot;</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;msg\&quot;:\&quot;登录成功\&quot;,\&quot;user\&quot;:&#123;\&quot;name\&quot;:\&quot;&quot;</span>+name+<span class="string">&quot;\&quot;,\&quot;password\&quot;:\&quot;&quot;</span>+password+<span class="string">&quot;\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-RMI实现RPC"><a href="#4-RMI实现RPC" class="headerlink" title="4.RMI实现RPC"></a>4.RMI实现RPC</h2><h3 id="1-RMI简介"><a href="#1-RMI简介" class="headerlink" title="1.RMI简介"></a>1.RMI简介</h3><p>RMI（Remote Method Invocation）：是Java语言的远程调用（基于TCP协议），无法实现跨语言。</p><p>RMI是从JDK1.2推出的功能，它可以实现在一个Java应用中可以像调用本地方法一样调用另一个服务器中Java应用（JVM）的内容。</p><h3 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2.执行流程"></a>2.执行流程</h3><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc/rpc2.png"></img></p><p>Registry（注册表）是放置所有服务对象的命名空间。</p><p>每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。这些是使用称为绑定名称的唯一名称注册的。</p><p>要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取（lookup()方法）</p><h3 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3.工作原理"></a>3.工作原理</h3><h4 id="3-1基础知识补充"><a href="#3-1基础知识补充" class="headerlink" title="3.1基础知识补充"></a>3.1基础知识补充</h4><p><b>Java IDL</b>是一种用于分布式对象的技术，即对象在网络上的不同平台上进行交互。Java IDL使对象能够进行交互，而不管它们是以Java编程语言还是C，C ++，COBOL或其他语言编写的。这是可能的，因为Java IDL基于<b>通用对象请求代理体系结构（CORBA）</b>，即行业标准的分布式对象模型。CORBA的主要功能是IDL，一种与语言无关的接口定义语言。每种支持CORBA的语言都有自己的IDL映射。顾名思义，Java IDL支持Java映射。为了支持单独程序中对象之间的交互，Java IDL提供了一个对象请求代理或ORB（Object Request Broker）。ORB是一个类库，可在Java IDL应用程序与其他符合CORBA的应用程序之间进行低层级的通信。</p><p><b>CORBA</b>，Common ObjectRequest Broker Architecture（公共对象请求代理体系结构），是由OMG组织制订的一种标准的面向对象应用程序体系规范。CORBA使用接口定义语言（IDL），用于指定对象提供给外部的接口。然后，CORBA指定从IDL到特定实现语言（如Java）的映射。CORBA规范规定应有一个对象请求代理（ORB），通过该对象应用程序与其他对象进行交互。通用InterORB协议（GIOP）摘要协议的创建是为了允许ORB间的通信，并提供了几种具体的协议，包括Internet InterORB协议（IIOP），它是GIOP的实现，可用于Internet，并提供GIOP消息和TCP&#x2F;IP层之间的映射。</p><p><b>IIOP</b>，Internet Inter-ORB Protocol(互联网内部对象请求代理协议)，它是一个用于CORBA 2.0及兼容平台上的协议；用来在CORBA对象请求代理之间交流的协议。Java中使得程序可以和其他语言的CORBA实现互操作性的协议。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc/rpc3.png"></img></p><p><b>RMI-IIOP</b>出现以前，只有RMI和CORBA两种选择来进行分布式程序设计，二者之间不能协作。RMI-IIOP综合了RMI 和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。RMI-IIOP综合了<b>RMI的简单性</b>&gt;和<b>CORBA的多语言性兼容性</b>，RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性。</p><p><b>JRMP</b>：Java远程方法协议（Java Remote Method Protocol），适用于RMI过程中的协议，只有使用这个协议，方法调用双方才能正常进行数据交流。</p><h4 id="3-2Client-amp-Server"><a href="#3-2Client-amp-Server" class="headerlink" title="3.2Client&amp;Server"></a>3.2Client&amp;Server</h4><p>从现在开始忘掉注册中心，假设注册中心从现在开始不存在<br>现在我们的需求是这样的：client想执行一个在远程机器上server的一个方法。</p><p>我们如何做到这一点？Java RMI 会处理这些问题，解决方案肯定会涉及到socket网络编程，因为server运行在远程机器上，解决这个问题的关键点在于两点：</p><ul><li>客户端如何从处理网络连接中解耦开来</li><li>客户端如何能就像调用本地方法一样来调用远程机器上的方法</li></ul><p>因此RMI 的开发人员就引入了 Stub 和 Skeleton模型。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc/rpc4.png"></img></p><p>所有与网络相关的代码都放在了Stub和Skeleton中，这样客户端和服务端就不需要处理网络相关的代码了。</p><p>Stub 同样也实现了和服务端同样 java.rmi.Remote接口，这样当 Client 想调用 Server 上方法的时候，就可以调用Stub 上的相同的方法，但是Stub里面只有和网络相关的处理逻辑，并没有对应的业务处理逻辑。比如说 Server 上有一个add()方法，Stub 中同样也有一个add()方法，但是Stub 上的这个add()方法并不包含添加的逻辑实现，它仅仅包含如何连接到远程的 Skeleton、调用方法的详细信息、参数、返回值等等。</p><h4 id="3-3RMIRegistry"><a href="#3-3RMIRegistry" class="headerlink" title="3.3RMIRegistry"></a>3.3RMIRegistry</h4><p>在socket层通信的过程如下：</p><ol><li>Server 在远程机器上监听一个端口。</li><li>Client并不知道Server 监听哪个端口，但是Stub 知道，这样Client可以调用Stub 上他想调用的任何方法。</li><li>Client调用Stub 上的方法</li><li>Stub链接Server 监听的端口并发送参数，详细过程如下：<ol><li>Client连接Server 监听的端口</li><li>Server 收到请求并创建一个Socket来处理这个链接</li><li>Server 继续监听请求</li><li>使用双方协定的信息，传送参数和结果</li><li>协议可以是JRMP或者 iiop</li></ol></li><li>方法在远程Server 上执行，并发执行结果返回给Stub</li><li>Stub返回结果给Client，就好像是Stub执行了这个方法一样。</li></ol><p>这样整个过程就结束了，但是等一下！回头再看第2点，说Stub知道Server在哪，他监听的端口，这怎么可能？如果Client不知道Server的host和port，他怎么能创建一个知道所有这一切的Stub对象呢？更何况是在服务端端口是随机选择的。</p><p>这就是 RMIRegistry 存在的必要了。RMIRegistry 可以认为是一个服务，它提供了一个hashMap，里面是 public_name, Stub_object 名值对。比如我有一个远程服务对象叫做 Scientific_Calculator，然后我想把这个服务对外公布为 calc，这样会在Server上创建一个Stub对象，然后把他注册到RMIRegistry ，这样Client就可以从RMIRegistry 中得到这个Stub对象了，你可以使用一个工具类 java.rmi.Naming 来方便的操作注册和操作。</p><h3 id="4-模拟实现"><a href="#4-模拟实现" class="headerlink" title="4.模拟实现"></a>4.模拟实现</h3><h4 id="4-1服务端接口"><a href="#4-1服务端接口" class="headerlink" title="4.1服务端接口"></a>4.1服务端接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个远程服务接口.RMI强制要求必须是Remote接口的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FirstInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="comment">//RMI强制要求所有的远程调用方法(包括构造方法)都必须抛出RemoteException</span></span><br><span class="line">    String <span class="title function_">first</span><span class="params">(String name)</span> <span class="keyword">throw</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2服务端实现类"><a href="#4-2服务端实现类" class="headerlink" title="4.2服务端实现类"></a>4.2服务端实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现远程服务接口。所有的远程服务实现，必须是Remote接口直接实现类或间接实现类</span></span><br><span class="line"><span class="comment">//如果不会创建基于RMI服务的标准实现，可以继承UnicastRemoteObject类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstRMIImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">FirstInterface</span>, Remote &#123;</span><br><span class="line">    <span class="comment">//RMI强制要求所有的远程调用方法(包括构造方法)都必须抛出RemoteException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstRMIImpl</span><span class="params">()</span> <span class="keyword">throw</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">first</span><span class="params">(String name)</span> <span class="keyword">throw</span> RemoteException&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3服务端主方法"><a href="#4-3服务端主方法" class="headerlink" title="4.3服务端主方法"></a>4.3服务端主方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RMI的Registry在创建的时候，会自动生成一个子线程，并升级成守护线程。提供持久的服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         <span class="type">FirstInterface</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建服务对象</span></span><br><span class="line">            first = <span class="keyword">new</span> <span class="title class_">FirstRMIImpl</span>();</span><br><span class="line">            <span class="comment">//注册到Registry</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//绑定一个服务到注册中心。提供命名，格式为：rim://ip:port/别名，命名冲突抛出异常</span></span><br><span class="line">            <span class="comment">//Naming.bind(&quot;rim://localhost:9999/first&quot;,first);</span></span><br><span class="line">            <span class="comment">//也可以使用rebind()方法，和bind()的区别是命名冲突会直接覆盖，</span></span><br><span class="line">            Naming.rebind(<span class="string">&quot;rim://localhost:9999/first&quot;</span>,first);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4客户端主方法"><a href="#4-4客户端主方法" class="headerlink" title="4.4客户端主方法"></a>4.4客户端主方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RMI的Registry在创建的时候，会自动生成一个子线程，并升级成守护线程。提供持久的服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         <span class="comment">//代理对象的创建</span></span><br><span class="line">         <span class="type">FirstInterface</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//使用 lookup 通过名字找服务，并自动创建代理对象。</span></span><br><span class="line">            <span class="comment">//类型是Object类型，对象一定是Proxy的子类型，且一定实现了服务接口</span></span><br><span class="line">            first = (FirstInterface) Naming.lookup(<span class="string">&quot;rim://localhost:9999/first&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> first.first(<span class="string">&quot;soul&quot;</span>);</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-自定义-RPC-框架"><a href="#5-自定义-RPC-框架" class="headerlink" title="5. 自定义 RPC 框架"></a>5. 自定义 RPC 框架</h2><ol><li><a href="">基于 Zookeeper&amp;RMI 的 Rpc 框架</a></li><li><a href="">基于 Netty 的 Rpc 框架</a></li></ol><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><p><a href="https://www.jianshu.com/p/2c78554a3f36">深入理解 RMI 原理</a></p><p><a href="https://paper.seebug.org/1105/">关于 Java 中的 RMI-IIOP</a></p><p><a href="https://www.bilibili.com/video/BV1y54y187cf/?spm_id_from=333.788.video.desc.click">尚学堂编程俱乐部</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-RPC简介&quot;&gt;&lt;a href=&quot;#1-RPC简介&quot; class=&quot;headerlink&quot; title=&quot;1.RPC简介&quot;&gt;&lt;/a&gt;1.RPC简介&lt;/h2&gt;&lt;p&gt;RPC（Remote Procedure Call）远程调用协议。RPC协议规定允许互联网中一台主机</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RPC(Zookeeper &amp; RMI)</title>
    <link href="http://example.com/2022/03/13/RPC(Zookeeper%20&amp;%20RMI)/"/>
    <id>http://example.com/2022/03/13/RPC(Zookeeper%20&amp;%20RMI)/</id>
    <published>2022-03-12T16:00:00.000Z</published>
    <updated>2022-05-24T03:28:37.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前几天想起自己基于（Netty &amp; Nacos）搭建的 Rpc 框架使用的是单体架构，一直想搭一个分布式架构的Rpc轮子。于是参考 <a href="https://space.bilibili.com/701029654?spm_id_from=333.788.b_765f7570696e666f.1">尚学堂编程俱乐部</a> 的 Rpc 代码，尝试了一次基于（Zookeeper &amp; RMI）的分布式架构的 Rpc 搭建。以下为本人整理的搭建过程（由于写这篇文章时时间紧张，模块的创建在文章中没有指明，那就贴个tree吧）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">D:.</span><br><span class="line">│  pom.xml</span><br><span class="line">│  RpcCnted.iml</span><br><span class="line">│  </span><br><span class="line">├─.idea</span><br><span class="line">│      .gitignore</span><br><span class="line">│      compiler.xml</span><br><span class="line">│      jarRepositories.xml</span><br><span class="line">│      misc.xml</span><br><span class="line">│      workspace.xml</span><br><span class="line">│      </span><br><span class="line">├─my_rpc</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │  </span><br><span class="line">│  ├─my_rpc_api</span><br><span class="line">│  │  │  pom.xml</span><br><span class="line">│  │  │  </span><br><span class="line">│  │  └─src</span><br><span class="line">│  │      └─main</span><br><span class="line">│  │          └─java</span><br><span class="line">│  │              └─com</span><br><span class="line">│  │                  └─soul</span><br><span class="line">│  │                      └─service</span><br><span class="line">│  │                              CustomerService.java</span><br><span class="line">│  │                              UserService.java</span><br><span class="line">│  │                              </span><br><span class="line">│  ├─my_rpc_client</span><br><span class="line">│  │  │  pom.xml</span><br><span class="line">│  │  │  </span><br><span class="line">│  │  └─src</span><br><span class="line">│  │      └─main</span><br><span class="line">│  │          ├─java</span><br><span class="line">│  │          │  └─com</span><br><span class="line">│  │          │      └─soul</span><br><span class="line">│  │          │              TestRpcClient.java</span><br><span class="line">│  │          │              </span><br><span class="line">│  │          └─resources</span><br><span class="line">│  │                  soul-rpc.properties</span><br><span class="line">│  │                  </span><br><span class="line">│  └─my_rpc_server</span><br><span class="line">│      │  pom.xml</span><br><span class="line">│      │  </span><br><span class="line">│      └─src</span><br><span class="line">│          └─main</span><br><span class="line">│              ├─java</span><br><span class="line">│              │  └─com</span><br><span class="line">│              │      └─soul</span><br><span class="line">│              │          │  ServerApplication.java</span><br><span class="line">│              │          │  </span><br><span class="line">│              │          └─service</span><br><span class="line">│              │              └─impl</span><br><span class="line">│              │                      CustomerServiceImpl.java</span><br><span class="line">│              │                      UserServiceImpl.java</span><br><span class="line">│              │                      </span><br><span class="line">│              └─resources</span><br><span class="line">│                      soul-rpc-services.properties</span><br><span class="line">│                      soul-rpc.properties</span><br><span class="line">│                      </span><br><span class="line">└─rpc_soul_framework</span><br><span class="line">    │  pom.xml</span><br><span class="line">    │  </span><br><span class="line">    └─src</span><br><span class="line">        └─main</span><br><span class="line">            ├─java</span><br><span class="line">            │  └─com</span><br><span class="line">            │      └─soul</span><br><span class="line">            │          └─rpc</span><br><span class="line">            │              │  SoulRpcFactory.java</span><br><span class="line">            │              │  </span><br><span class="line">            │              ├─connection</span><br><span class="line">            │              │      ZkConnection.java</span><br><span class="line">            │              │      </span><br><span class="line">            │              └─registry</span><br><span class="line">            │                      SoulRpcRegistry.java</span><br><span class="line">            │                      </span><br><span class="line">            └─resources</span><br><span class="line">                    soul-rpc.properties</span><br><span class="line">                    </span><br></pre></td></tr></table></figure><h2 id="1-RMI-服务端"><a href="#1-RMI-服务端" class="headerlink" title="1. RMI 服务端"></a>1. RMI 服务端</h2><p>首先我们先创建一个服务端接口与其实现类。很 easy 是吧！</p><h3 id="1-1定义接口"><a href="#1-1定义接口" class="headerlink" title="1.1定义接口"></a>1.1定义接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RMI 的接口需要继承 Remote ，方法都需要抛出 RemoteException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="comment">//根据用户名查询用户，返回一个字符串</span></span><br><span class="line">    String <span class="title function_">getUser</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2定义接口的实现类"><a href="#1-2定义接口的实现类" class="headerlink" title="1.2定义接口的实现类"></a>1.2定义接口的实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户服务实现类</span></span><br><span class="line"><span class="comment">// RMI 的接口实现类则继承 UnicastRemoteObject 就好 ，方法也需要抛出 RemoteException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;要查询的用户是：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;&quot;</span>+name+<span class="string">&quot;\&quot;,\&quot;age\&quot;:20,\&quot;gender\&quot;,\&quot;男\&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-注册-RMI-服务"><a href="#2-注册-RMI-服务" class="headerlink" title="2. 注册 RMI 服务"></a>2. 注册 RMI 服务</h2><p>最简单的第一步做完了！迈出第一步，我们已经成功一半了！接下来我们需要把 RMI 的服务给注册到它的 <b>RMIRegistry</b> 中。那我们就定义一个类来专门注册RMI 的服务吧！</p><p>首先我们知道，RMIRegistry 存储服务的key是一个固定格式的字符串。</p><p>它的基本格式为 ：rmi格式为：<code>&quot;rmi://ip:port/interface&quot;</code> , 所以我们先把 ip 和 port 定义出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoulRpcRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK！我们开始注册，添加一个注册服务的方法，参数当然是服务 <code>interface</code> 了。这里因为我们使用的是 RMI ，定义的服务端接口都是Remote的子类，所以这里就使用泛型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>，</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoulRpcRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceInterface - 服务接口类的对象。 如：com.soul.service.UserService.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceObject    - 服务类实现类型的对象。 如：com.soul.service.impl.USerServiceImpl.class</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registryService</span><span class="params">(Class&lt;? extends Remote&gt; serviceInterface, Remote serviceObject)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//rmi = rmi://ip:port/com.soul.service.UserService</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rmi</span> <span class="operator">=</span> <span class="string">&quot;rmi://&quot;</span> + ip + <span class="string">&quot;:&quot;</span> + port + <span class="string">&quot;/&quot;</span> + serviceInterface.getName();</span><br><span class="line">        <span class="comment">//注册服务对象</span></span><br><span class="line">        Naming.rebind(rmi, serviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的 RMI 注册服务也完成了！</p><h2 id="3-连接Zookeeper"><a href="#3-连接Zookeeper" class="headerlink" title="3. 连接Zookeeper"></a>3. 连接Zookeeper</h2><p>我们想要把 RMI 中存储的服务端信息 存到 Zookeeper 中，首先就要连接Zookeeper。</p><p>既然是Zookeeper的连接类，就需要 Zookeeper 的连接地址，还有连接的最大超时时间。教练教练，这个我会！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkConnection</span> &#123;</span><br><span class="line">    <span class="comment">//保存zk的地址，格式为：ip:port。如：192.168.169.130：2181</span></span><br><span class="line">    <span class="keyword">private</span> String zkServer;</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sessionTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在构造方法里初始化这两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置 Zookeeper连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ZkConnection</span><span class="params">(String zkServer, <span class="type">int</span> sessionTimeout)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.zkServer = zkServer;</span><br><span class="line">    <span class="built_in">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//设置无参数 Zookeeper连接，给定默认值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ZkConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.zkServer = <span class="string">&quot;localhost:2181&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.sessionTimeout = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后与 Zookeeper 进行连接 ，返回值类型Zookeeper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ZooKeeper <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(zkServer, sessionTimeout, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">            <span class="comment">//不知道写啥就先空着呗</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Zookeeper注册"><a href="#4-Zookeeper注册" class="headerlink" title="4. Zookeeper注册"></a>4. Zookeeper注册</h2><p>我们已经把服务注册到 RMI 的 Registry 中了，现在只需要把 RMI 中存储的 访问地址 URI 存储到 Zookeeper 中。</p><p>既然要注册，必然需要我们上一步的定义的 <code>ZkConnection</code> 来帮我们连接 Zookeeper，所以我们在 <code>SoulRpcRegistry</code> 中增加 <code>ZkConnection</code> 属性，并修改 <code>registryService</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zookeeper连接对象</span></span><br><span class="line"><span class="keyword">private</span> ZkConnection connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册服务的方法</span></span><br><span class="line"><span class="comment"> * 1.拼接RMI的访问地址URI</span></span><br><span class="line"><span class="comment"> * 2.把访问地址URI存储在Zookeeper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceInterface - 服务接口类的对象。 如：com.soul.service.UserService.class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceObject - 服务类实现类型的对象。 如：com.soul.service.impl.USerServiceImpl.class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception - 抛出异常代表注册失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registryService</span><span class="params">(Class&lt;? extends Remote&gt; serviceInterface, Remote serviceObject)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//rmi = rmi://ip:port/com.soul.service.UserService</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rmi</span> <span class="operator">=</span> <span class="string">&quot;rmi://&quot;</span> + ip + <span class="string">&quot;:&quot;</span> + port + <span class="string">&quot;/&quot;</span> + serviceInterface.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把服务对象在RMI的registry中注册</span></span><br><span class="line">    Naming.rebind(rmi, serviceObject);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接一个有规则的zk存储节点命名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/soul/rpc/&quot;</span> + serviceInterface.getName();</span><br><span class="line">    connection.getConnection().create(path, rmi.getBytes(),</span><br><span class="line">                                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就大功告成了？no no no！我们只在 Zookeeper 中存服务进去可不行，也得取出来用呀，不然我这不白存啦？</p><p>那我们就在 <code>SoulRpcRegistry</code> 中添加一个取的方法，首先拿到节点数据，然后再去 <code>RMIRegistry</code> 中拿到客户端的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据服务接口类型访问zk，获取RMI的远程代理对象</span></span><br><span class="line"><span class="comment"> * 1.拼接一个zk中的节点名称</span></span><br><span class="line"><span class="comment"> * 2.访问zk，查询节点中存储的数据</span></span><br><span class="line"><span class="comment"> * 3.根据查询的结果，创建一个代理对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Remote</span>&gt; T <span class="title function_">getServiceProxy</span><span class="params">(Class&lt;T&gt; serviceInterface)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException, NotBoundException &#123;</span><br><span class="line">    <span class="comment">//拼接zk中的节点名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/soul/rpc/&quot;</span> + serviceInterface.getName();</span><br><span class="line">    <span class="comment">//查询节点中存储的数据</span></span><br><span class="line">    <span class="type">byte</span>[] datas = connection.getConnection().getData(path, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//把查询的字节数组，翻译成RMI的访问地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rmi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(datas);</span><br><span class="line">    <span class="comment">//返回代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Naming.lookup(rmi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样整个注册器我们就写好啦！</p><h2 id="5-初始化参数"><a href="#5-初始化参数" class="headerlink" title="5. 初始化参数"></a>5. 初始化参数</h2><h3 id="5-1-参数配置文件"><a href="#5-1-参数配置文件" class="headerlink" title="5.1 参数配置文件"></a>5.1 参数配置文件</h3><p>我们知道 ，无论是 RMI 还是 Zookeeper ，都需要一些固定格式的参数来使用，比如 ip、port等。这些参数一旦发生变化，我们想要修改就会变得很麻烦，需要去代码里面疯狂 Ctrl + F ，所以最好使用一个配置文件来存储这些参数的值。</p><p>定义一个配置文件 (.properties) ：</p><p><code>soul-rpc.properties:</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">registry.ip</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">registry.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="attr">zk.server</span>=<span class="string">192.168.169.130:2181</span></span><br><span class="line"><span class="attr">zk.sessionTimeout</span>=<span class="string">20000</span></span><br></pre></td></tr></table></figure><h3 id="5-2-加载配置文件"><a href="#5-2-加载配置文件" class="headerlink" title="5.2 加载配置文件"></a>5.2 加载配置文件</h3><p>好嘞，我们参数的配置文件定义好了，接下来有个新问题：什么时候加载配置文件呢？那肯定是在使用 Zookeeper 或 RMI 之前呀！</p><p>那我们就定义一个服务端的入口类呗，在入口类的代码块或者构造方法中加载配置文件不就得了！而且要记得我们 RMI 的注册器也还没创建呢，可以在这个入口类中一并创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoulRpcFactory</span> &#123;</span><br><span class="line">    <span class="comment">//保存配置信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Properties</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ZkConnection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SoulRpcRegistry registry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化过程。</span></span><br><span class="line"><span class="comment">     * 固定逻辑：在classpath下，配置文件。命名为: soul-rpc.properties</span></span><br><span class="line"><span class="comment">     * 配置文件结构固化：</span></span><br><span class="line"><span class="comment">     *  registry.ip = 服务端Ip地址，默认为 localhost</span></span><br><span class="line"><span class="comment">     *  registry.port = 服务端端口号，默认为 9090</span></span><br><span class="line"><span class="comment">     *  zk.server = Zookeeper访问地址，默认为 localhost:2181</span></span><br><span class="line"><span class="comment">     *  zk.sessionTimeout = Zookeeper连接会话超时，默认10s</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取classpath类路径下的配置文件输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> SoulRpcFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;soul-rpc.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//读取配置文件，初始化配置对象</span></span><br><span class="line">            config.load(input);</span><br><span class="line">            <span class="comment">//获取服务端ip</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">serverIp</span> <span class="operator">=</span> config.getProperty(<span class="string">&quot;registry.ip&quot;</span>) == <span class="literal">null</span> </span><br><span class="line">                ? <span class="string">&quot;localhost&quot;</span> : config.getProperty(<span class="string">&quot;registry.ip&quot;</span>);</span><br><span class="line">            <span class="comment">//获取服务端port</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> config.getProperty(<span class="string">&quot;registry.port&quot;</span>)  == <span class="literal">null</span> </span><br><span class="line">                ? <span class="number">9090</span> : Integer.parseInt(config.getProperty(<span class="string">&quot;registry.port&quot;</span>));</span><br><span class="line">            <span class="comment">//获取zk服务器地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">zkServer</span> <span class="operator">=</span> config.getProperty(<span class="string">&quot;zk.server&quot;</span>) == <span class="literal">null</span> </span><br><span class="line">                ? <span class="string">&quot;localhost:2181&quot;</span> : config.getProperty(<span class="string">&quot;zk.server&quot;</span>);</span><br><span class="line">            <span class="comment">//获取zk客户端会话超时时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">zkSessionTimeout</span> <span class="operator">=</span> config.getProperty(<span class="string">&quot;zk.sessionTimeout&quot;</span>) == <span class="literal">null</span> </span><br><span class="line">                ? <span class="number">10000</span> : Integer.parseInt(config.getProperty(<span class="string">&quot;zk.sessionTimeout&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建连接对象</span></span><br><span class="line">            connection = <span class="keyword">new</span> <span class="title class_">ZkConnection</span>(zkServer,zkSessionTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建注册器对象</span></span><br><span class="line">            registry = <span class="keyword">new</span> <span class="title class_">SoulRpcRegistry</span>(serverIp,serverPort,connection);</span><br><span class="line">            <span class="comment">//创建RMI的注册器</span></span><br><span class="line">            LocateRegistry.createRegistry(serverPort);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//初始化代码块发生异常的时候，抛出错误，中断虚拟机</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是入口类，那我们可以把 <code>SoulRpcRegistry</code> 的注册服务的方法 和 获取代理对象的方法 也交给这个入口类管理，那就简简单单在这个类中添加两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供一个快速的注册服务的静态工具方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(Class&lt;? extends Remote&gt; serviceInterface, Remote serviceObject)</span> <span class="keyword">throws</span> InterruptedException, IOException, KeeperException &#123;</span><br><span class="line">    registry.registryService(serviceInterface,serviceObject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供一个快速的拿到客户端代理对象的静态工具方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Remote</span>&gt; T <span class="title function_">getServiceProxy</span><span class="params">(Class&lt;T&gt; serviceInterface)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="keyword">return</span> registry.getServiceProxy(serviceInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK! 小功告成！接下来测试一下服务端能否使用吧！</p><h2 id="6-测试服务端"><a href="#6-测试服务端" class="headerlink" title="6. 测试服务端"></a>6. 测试服务端</h2><p>写个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建一个服务对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        SoulRpcFactory.registerService(UserService.class, userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动！😭：发现报错</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc(z&r)/1.png"></img></p><p>原来是父节点没创建呀，搞什么啊，就这？直接加个判断解决它！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//--此处代码省略--</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化zk中的父节点/soul/rpc</span></span><br><span class="line">        List&lt;String&gt; children = connection.getConnection().getChildren(<span class="string">&quot;/&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 不存在子节点 /soul</span></span><br><span class="line">        <span class="keyword">if</span>(!children.contains(<span class="string">&quot;soul&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 创建节点/soul</span></span><br><span class="line">            connection.getConnection()</span><br><span class="line">                .create(<span class="string">&quot;/soul&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; soulChildren = connection.getConnection().getChildren(<span class="string">&quot;/soul&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!soulChildren.contains(<span class="string">&quot;rpc&quot;</span>))&#123;</span><br><span class="line">            connection.getConnection()</span><br><span class="line">                .create(<span class="string">&quot;/soul/rpc&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//初始化代码块发生异常的时候，抛出错误，中断虚拟机</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美启动</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc(z&r)/2.png"></img></p><p>接下来去Zookeeper 瞅瞅，发现成功存入。那就查看一下value值。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc(z&r)/3.png"></img></p><h2 id="7-服务端启动问题"><a href="#7-服务端启动问题" class="headerlink" title="7. 服务端启动问题"></a>7. 服务端启动问题</h2><h3 id="7-1-增加服务配置文件"><a href="#7-1-增加服务配置文件" class="headerlink" title="7.1 增加服务配置文件"></a>7.1 增加服务配置文件</h3><p>在上一步我们的服务端启动成功了，但是有个小问题哈，这时候我们只有一个 <code>UserService</code> 服务。当我们有多个服务时，我们难道要一个个在服务端一个个的注册调用吗？这也太麻烦了吧，所以我们仍然是使用配置文件来帮我们解决这个问题。</p><h4 id="7-1-1-服务配置文件"><a href="#7-1-1-服务配置文件" class="headerlink" title="7.1.1 服务配置文件"></a>7.1.1 服务配置文件</h4><p><code>soul-rpc-services.properties:</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件格式是：接口全命名=实现类全命名</span></span><br><span class="line"><span class="attr">com.soul.service.UserService</span>=<span class="string">com.soul.service.impl.UserServiceImpl</span></span><br><span class="line"><span class="attr">com.soul.service.CustomerService</span>=<span class="string">com.soul.service.impl.CustomerServiceImpl</span></span><br></pre></td></tr></table></figure><h4 id="7-1-2-加载配置文件"><a href="#7-1-2-加载配置文件" class="headerlink" title="7.1.2 加载配置文件"></a>7.1.2 加载配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoulRpcFactory</span> &#123;</span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于读取初始化的配置对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Properties</span> <span class="variable">services</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//代码省略</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿到配置文件(soul-rpc-services.properties)。如果有则自动初始化，没有则忽略后续逻辑</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">servicesInput</span> <span class="operator">=</span> SoulRpcFactory.class</span><br><span class="line">                    .getClassLoader().getResourceAsStream(<span class="string">&quot;soul-rpc-services.properties&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (servicesInput != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//有配置 初始化</span></span><br><span class="line">                services.load(servicesInput);</span><br><span class="line">                <span class="comment">//遍历集合services</span></span><br><span class="line">                <span class="keyword">for</span>(Map.Entry&lt;Object,Object&gt; entry : services.entrySet())&#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> services.get(key);</span><br><span class="line">                    Class&lt;Remote&gt; serviceInterface = (Class&lt;Remote&gt;) Class.forName(key.toString());</span><br><span class="line">                    <span class="type">Remote</span> <span class="variable">serviceObject</span> <span class="operator">=</span> (Remote) Class.forName(value.toString()).newInstance();</span><br><span class="line">                    <span class="comment">//有了接口的类对象以及服务的对象后，可以开始注册</span></span><br><span class="line">                    registry.registryService(serviceInterface,serviceObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-3-修改启动类"><a href="#7-1-3-修改启动类" class="headerlink" title="7.1.3 修改启动类"></a>7.1.3 修改启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.soul.rpc.SoulRpcFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-节点已创建问题"><a href="#7-2-节点已创建问题" class="headerlink" title="7.2 节点已创建问题"></a>7.2 节点已创建问题</h3><p>如果我们重复创建同一个节点，会报这个错误。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc(z&r)/4.png"></img></p><p>那就想策略吧：每次创建前先进行一次查询判断，如果要创建的节点已经存在了，就先删除掉这个节点，然后重新创建新的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoulRpcRegistry</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registryService</span><span class="params">(Class&lt;? extends Remote&gt; serviceInterface, Remote serviceObject)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//rmi = rmi://ip:port/com.soul.service.UserService</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rmi</span> <span class="operator">=</span> <span class="string">&quot;rmi://&quot;</span> + ip + <span class="string">&quot;:&quot;</span> + port + <span class="string">&quot;/&quot;</span> + serviceInterface.getName();</span><br><span class="line">        <span class="comment">//拼接一个有规则的zk存储节点命名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/soul/rpc/&quot;</span> + serviceInterface.getName();</span><br><span class="line">        <span class="comment">//把服务对象在RMI的registry中注册</span></span><br><span class="line">        Naming.rebind(rmi, serviceObject);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; children = connection.getConnection().getChildren(<span class="string">&quot;/soul/rpc&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//如果节点已经存在，删除掉</span></span><br><span class="line">        <span class="keyword">if</span> (children.contains(serviceInterface.getName()))&#123;</span><br><span class="line">            <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">            connection.getConnection().getData(path,<span class="literal">false</span>,stat);</span><br><span class="line">            connection.getConnection().delete(path,stat.getCversion());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注册到Zookeeper</span></span><br><span class="line">        connection.getConnection().create(path, rmi.getBytes(),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次启动，成功运行！</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc(z&r)/5.png"></img></p><h2 id="8-RMI-客户端"><a href="#8-RMI-客户端" class="headerlink" title="8. RMI 客户端"></a>8. RMI 客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试基于自定义Rpc框架的客户端开发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRpcClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过自定义框架，连接zk，获取接口的动态代理对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> SoulRpcFactory.getServiceProxy(UserService.class);</span><br><span class="line">            System.out.println(userService.getClass().getName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> userService.getUser(<span class="string">&quot;SoulChay&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;远程服务返回查询结果：&quot;</span> + res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接启动，直接成功！（不成功的也不会放上来是叭）</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/rpc(z&r)/6.png"></img></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这样我们基于 (Zookeeper &amp; RMI) 的简单RPC框架就搭建好了。</p><p>之后我会把它完善一下放在GitHub上，文章有不对的地方或者您有什么想法都欢迎评论留言。</p><p>感谢阅读到最后！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;前几天想起自己基于（Netty &amp;amp; Nacos）搭建的 Rpc 框架使用的是单体架构，一直想搭一个分布式架构的Rpc</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper-note</title>
    <link href="http://example.com/2022/03/10/Zookeeper/"/>
    <id>http://example.com/2022/03/10/Zookeeper/</id>
    <published>2022-03-09T16:00:00.000Z</published>
    <updated>2022-05-24T04:56:32.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper介绍"><a href="#1-Zookeeper介绍" class="headerlink" title="1.Zookeeper介绍"></a>1.Zookeeper介绍</h2><ul><li>Zookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。</li><li>Zookeeper从设计模式角度来理解：是基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</li></ul><h3 id="1-1-Zookeeper结构"><a href="#1-1-Zookeeper结构" class="headerlink" title="1.1 Zookeeper结构"></a>1.1 Zookeeper结构</h3><p>Zookeeper 数据模型的结构与Unix文件系统很类似，整体上可以看做是一棵树，每个节点称作一个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper1.png"></img></p><h3 id="1-2-配置-Zookeeper"><a href="#1-2-配置-Zookeeper" class="headerlink" title="1.2 配置 Zookeeper"></a>1.2 配置 Zookeeper</h3><p>Zookeeper 在启动时会去 conf 目录下寻找 zoo.cfg 的配置文件。所以我们需要进入到conf目录拷贝一个zoo_sample.cfg并完成配置 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到conf目录</span></span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝</span></span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure><p>修改zoo.cfg 中的 dataDir</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">dataDir=/opt/zookeeper/zkdata</span><br></pre></td></tr></table></figure><h3 id="1-3-Zookeeper常用命令"><a href="#1-3-Zookeeper常用命令" class="headerlink" title="1.3 Zookeeper常用命令"></a>1.3 Zookeeper常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">连接ZooKeeper服务端</span></span><br><span class="line">./zkCli.sh –server ip:port</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">断开连接</span></span><br><span class="line">quit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示指定目录下节点</span></span><br><span class="line">ls 目录</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建节点</span></span><br><span class="line">create /节点path value</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取节点值</span></span><br><span class="line">get /节点path</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置节点值</span></span><br><span class="line">set /节点path value</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除单个节点</span></span><br><span class="line">delete /节点path</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除带有子节点的节点</span></span><br><span class="line">deleteall /节点path</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建临时节点</span></span><br><span class="line">create -e /节点path value</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建顺序节点</span></span><br><span class="line">create -s /节点path value</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询节点详细信息</span></span><br><span class="line">ls –s /节点path </span><br></pre></td></tr></table></figure><h2 id="2-Curator-API"><a href="#2-Curator-API" class="headerlink" title="2.Curator API"></a>2.Curator API</h2><p>我们在Java客户端操作 Zookeeper 有两种方式：①使用原生代码；②使用Curator。</p><p>这里介绍Curator，Zookeeper原生代码的使用可参考我另一篇文章 RPC(Zookeeper &amp; RMI)。</p><ul><li>Curator 是一套开源的 Zookeeper客户端框架。</li><li>它帮助我们在Zookeeper原生API基础上进行封装，实现一些开发细节。包括接连重连、反复注册Watcher和NodeExistsException等。</li><li>除此之外，Curator还提供了Zookeeper的各种应用场景：Recipe、共享锁服务、Master选举机制和分布式计数器等。</li></ul><h3 id="2-1-建立连接"><a href="#2-1-建立连接" class="headerlink" title="2.1 建立连接"></a>2.1 建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先声明重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);<span class="comment">//睡3秒尝试一次连接,最多尝试10次</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * @param connectString        连接字符串: &quot;192.168.169.130:2181,192.168.169.131:2181&quot;</span></span><br><span class="line"><span class="comment">         * @param sessionTimeoutMs     会话超时时间,单位毫秒</span></span><br><span class="line"><span class="comment">         * @param connectionTimeoutMs  连接超时时间,单位毫秒</span></span><br><span class="line"><span class="comment">         * @param retryPolicy          重试策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client1</span> <span class="operator">=</span> CuratorFrameworkFactory</span><br><span class="line">                .newClient(<span class="string">&quot;192.168.169.130:2181&quot;</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="number">15</span> * <span class="number">1000</span>, retryPolicy);</span><br><span class="line">        <span class="comment">//开启连接</span></span><br><span class="line">        client1.start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-创建节点"><a href="#2-2-创建节点" class="headerlink" title="2.2 创建节点"></a>2.2 创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);<span class="comment">//重试策略</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点 持久/临时  顺序/非顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.基本创建</span></span><br><span class="line">        <span class="comment">//如果创建节点没有指定数据,则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建节点,带有数据</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/app2&quot;</span>,<span class="string">&quot;SOUL&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建节点,带有节点类型</span></span><br><span class="line">        <span class="comment">//节点默认持久化</span></span><br><span class="line">        client.create().withMode(CreateMode.PERSISTENT).forPath(<span class="string">&quot;/app3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建多级节点</span></span><br><span class="line">        <span class="comment">//creatingParentsIfNeeded():如果父节点不存在则创建父节点</span></span><br><span class="line">        client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">&quot;/app4/p1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-查询节点"><a href="#2-3-查询节点" class="headerlink" title="2.3 查询节点"></a>2.3 查询节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//查询数据,对应linux:get</span></span><br><span class="line">        <span class="type">byte</span>[] data = client.getData().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询子节点,对应linux:ls</span></span><br><span class="line">        List&lt;String&gt; path = client.getChildren().forPath(<span class="string">&quot;/app4&quot;</span>);</span><br><span class="line">        System.out.println(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询子节点状态信息,对应linux:ls -s</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">        client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">        System.out.println(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-修改节点"><a href="#2-4-修改节点" class="headerlink" title="2.4 修改节点"></a>2.4 修改节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.基本修改</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/app1&quot;</span>,<span class="string">&quot;soul1&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据版本修改：为了避免多个客户端修改冲突问题，需要加入节点状态信息中的version</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">        client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> status.getVersion();</span><br><span class="line">        client.setData().withVersion(version).forPath(<span class="string">&quot;/app1&quot;</span>,<span class="string">&quot;soul2&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-删除节点"><a href="#2-5-删除节点" class="headerlink" title="2.5 删除节点"></a>2.5 删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.删除单个节点</span></span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.删除带有子节点的节点</span></span><br><span class="line">        client.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;/app4&quot;</span>);</span><br><span class="line">        <span class="comment">//3.保证删除节点</span></span><br><span class="line">        client.delete().guaranteed().forPath(<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">        <span class="comment">//4.带有回调函数的删除</span></span><br><span class="line">        client.delete().guaranteed().inBackground(<span class="keyword">new</span> <span class="title class_">BackgroundCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processResult</span><span class="params">(CuratorFramework curatorFramework,</span></span><br><span class="line"><span class="params">                                      CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被删除了= =&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).forPath(<span class="string">&quot;/app3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-Watch事务监听"><a href="#2-6-Watch事务监听" class="headerlink" title="2.6 Watch事务监听"></a>2.6 Watch事务监听</h3><p>Zookeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性</p><p>ZooKeeper 中引入了Watcher机制来实现了发布&#x2F;订阅功能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</p><p>Curator API中引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</p><p>Zookeeper 下有几个客户端，他们通过 Curator 来进行一系列的操作</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper2.png"></img></p><p>Zookeeper提供了三种Watcher：</p><ul><li>NodeCache：监听指定的ZNode节点。</li><li>PathChildrenCache：监听指定ZNode节点的子节点（不包含指定节点）。</li><li>TreeCache：监听指定节点及其子孙节点。</li></ul><h4 id="2-6-1-NodeCache"><a href="#2-6-1-NodeCache" class="headerlink" title="2.6.1 NodeCache"></a>2.6.1 NodeCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorWatcherTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NodeCache:给指定一个节点注册监听器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建NodeCache对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client,<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">        <span class="comment">//注册监听</span></span><br><span class="line">        nodeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">NodeCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Node changed&quot;</span>);</span><br><span class="line">                <span class="comment">//获取修改节点后的数据</span></span><br><span class="line">                <span class="type">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启监听: 如果设置为true,则开启监听时，加载缓冲数据</span></span><br><span class="line">        nodeCache.start(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为执行这个方法后连接断开，所以在测试时使用循环保证这个连接不会断开</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-6-1-PathChildrenCache"><a href="#2-6-1-PathChildrenCache" class="headerlink" title="2.6.1 PathChildrenCache"></a>2.6.1 PathChildrenCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorWatcherTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PathChildrenCache:监听某个节点的所有子节点(不包括被监听的节点)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建PathChildrenCache对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client,<span class="string">&quot;/app2&quot;</span>,<span class="literal">true</span>);<span class="comment">//是否缓存一些状态信息</span></span><br><span class="line">        <span class="comment">//绑定监听器</span></span><br><span class="line">        pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">PathChildrenCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework curatorFramework,</span></span><br><span class="line"><span class="params">                                   PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(event);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line">                <span class="comment">//1.获取类型</span></span><br><span class="line">                PathChildrenCacheEvent.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> event.getType();</span><br><span class="line">                <span class="comment">//2.判断类型是否是update</span></span><br><span class="line">                <span class="keyword">if</span> (type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node updated&quot;</span>);</span><br><span class="line">                    <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(PathChildrenCacheEvent.Type.CHILD_ADDED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node added&quot;</span>);</span><br><span class="line">                    <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(PathChildrenCacheEvent.Type.CHILD_REMOVED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node removed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启监听</span></span><br><span class="line">        pathChildrenCache.start();</span><br><span class="line">        <span class="comment">//因为执行这个方法后连接断开，所以在测试时使用循环保证这个连接不会断开</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-6-3-TreeCache"><a href="#2-6-3-TreeCache" class="headerlink" title="2.6.3 TreeCache"></a>2.6.3 TreeCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorWatcherTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).namespace(<span class="string">&quot;soul&quot;</span>).build(); <span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TreeCache:监听某个节点及其所有子节点(包括被监听的节点)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTreeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建PathChildrenCache对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(client,<span class="string">&quot;/app3&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定监听器</span></span><br><span class="line">        treeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">TreeCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework curatorFramework, </span></span><br><span class="line"><span class="params">                                   TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Node changed&quot;</span>);</span><br><span class="line">                System.out.println(event);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line">                <span class="comment">//1.获取类型</span></span><br><span class="line">                TreeCacheEvent.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> event.getType();</span><br><span class="line">                <span class="comment">//2.判断类型是否是update</span></span><br><span class="line">                <span class="keyword">if</span> (type.equals(TreeCacheEvent.Type.NODE_UPDATED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node updated&quot;</span>);</span><br><span class="line">                    <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(TreeCacheEvent.Type.NODE_ADDED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node added&quot;</span>);</span><br><span class="line">                    <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(TreeCacheEvent.Type.NODE_REMOVED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node removed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启监听</span></span><br><span class="line">        treeCache.start();</span><br><span class="line">        <span class="comment">//因为执行这个方法后连接断开，所以在测试时使用循环保证这个连接不会断开</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-7-Zookeeper分布式锁"><a href="#2-7-Zookeeper分布式锁" class="headerlink" title="2.7  Zookeeper分布式锁"></a>2.7  Zookeeper分布式锁</h3><h4 id="2-7-1-分布式锁引入"><a href="#2-7-1-分布式锁引入" class="headerlink" title="2.7.1 分布式锁引入"></a>2.7.1 分布式锁引入</h4><p>在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者lock的方式来解决多线程之间代码同步的问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。</p><p>但是当我们的应用是分布式集群工作的情况下，数据多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁来解决问题，那就需要一种更加高级的锁机制来处理<b>跨机器的进程之间的数据同步问题</b>——这就是分布式锁。</p><p>单一JVM下的工作环境：</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper3.png"></img></p><p>跨JVM下的工作环境：</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper4.png"></img></p><p>分布式锁有以下几种实现方式：</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper5.png"></img></p><h4 id="2-7-2-分布式锁原理"><a href="#2-7-2-分布式锁原理" class="headerlink" title="2.7.2 分布式锁原理"></a>2.7.2 分布式锁原理</h4><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper6.png"></img></p><p>核心思想：当客户端要获取锁，则创建一节点，使用完锁，则删除该节点。</p><p>1.客户端获取锁的时候，在lock节点下创建<b>临时顺序</b>节点。</p><p>2.然后获取lock下面的所有子节点，客户端获取到所有的子节点后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</p><p>3.如果发现自己创建的节点并非lock所有节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，用来监听这个节点的删除事件。</p><p>4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应的通知，此时再次判断自己创建的节点是否是lock节点中序号最小的，如果是则获取到了锁；如果不是则重复以上步骤继续获取比自己小的节点并对其注册一个删除监听。</p><h4 id="2-7-3-分布式锁的应用"><a href="#2-7-3-分布式锁的应用" class="headerlink" title="2.7.3 分布式锁的应用"></a>2.7.3 分布式锁的应用</h4><p>12306购票案例</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper7.png"></img></p><h5 id="2-7-3-1-客户端具体实现"><a href="#2-7-3-1-客户端具体实现" class="headerlink" title="2.7.3.1 客户端具体实现"></a>2.7.3.1 客户端具体实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tickets12306</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tickets12306</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.169.130:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy).build();<span class="comment">//可以加上命名空间,表示节点的根目录</span></span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//创建分布式锁</span></span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client,<span class="string">&quot;/lock&quot;</span>); <span class="comment">//参数：client + path</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程获取锁（每3s获取一次锁）</span></span><br><span class="line">                lock.acquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + tickets);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//线程释放锁</span></span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-7-3-2-客户端的调用"><a href="#2-7-3-2-客户端的调用" class="headerlink" title="2.7.3.2 客户端的调用"></a>2.7.3.2 客户端的调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tickets12306</span> <span class="variable">tickets12306</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tickets12306</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tickets12306,<span class="string">&quot;飞猪&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tickets12306,<span class="string">&quot;携程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Zookeeper集群"><a href="#3-Zookeeper集群" class="headerlink" title="3  Zookeeper集群"></a>3  Zookeeper集群</h2><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper8.png"></img></p><h3 id="3-1-Leader-选举"><a href="#3-1-Leader-选举" class="headerlink" title="3.1 Leader 选举"></a>3.1 Leader 选举</h3><p>Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举：(1) 服务器初始化启动；(2) 服务器运行期间无法和Leader保持连接。</p><h4 id="3-1-1-集群中的服务器状态"><a href="#3-1-1-集群中的服务器状态" class="headerlink" title="3.1.1 集群中的服务器状态"></a>3.1.1 集群中的服务器状态</h4><ul><li><b>LOOKING</b> ：寻找 Leader状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入Leader选举状态。</li><li><b>LEADING</b> ：领导者状态。表明当前服务器角色是Leader。</li><li><b>FOLLOWING</b> ：跟随者状态。表明当前服务器角色是Follower。</li><li><b>OBSERVING</b> ：观察者状态。表明当前服务器角色是Observer。该节点不参与 Leader 选举。</li></ul><h4 id="3-1-2-启动时期Leader选举"><a href="#3-1-2-启动时期Leader选举" class="headerlink" title="3.1.2 启动时期Leader选举"></a>3.1.2 启动时期Leader选举</h4><p>　若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下</p><ol><li><b>每个Server发出一个投票</b>。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的 <b>myid(服务器id) </b> 和 <b>ZXID（数据权重id）</b>，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</li><li><b>接受来自各个服务器的投票</b>。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</li><li><b>处理投票</b>。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下<ol><li>优先检查 <b>ZXID</b>。ZXID比较大的服务器优先作为Leader。</li><li>如果ZXID相同，那么就比较 <b>myid</b>。myid较大的服务器作为Leader服务器。</li><li>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</li></ol></li><li><b>统计投票</b>。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</li><li><b>改变服务器状态</b>。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</li></ol><h4 id="3-1-3-运行时期Leader选举"><a href="#3-1-3-运行时期Leader选举" class="headerlink" title="3.1.3 运行时期Leader选举"></a>3.1.3 运行时期Leader选举</h4><p>在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。</p><h4 id="3-1-4-Leader选举算法分析"><a href="#3-1-4-Leader选举算法分析" class="headerlink" title="3.1.4 Leader选举算法分析"></a>3.1.4 Leader选举算法分析</h4><p>在3.4.0后的Zookeeper的版本只保留了TCP版本的FastLeaderElection选举算法。当一台机器进入Leader选举时，当前集群可能会处于以下两种状态：</p><p>① 集群中已经存在Leader：对于集群中已经存在Leader而言，此种情况一般都是某台机器启动得较晚，在其启动之前，集群已经在正常工作，对这种情况，该机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器而言，仅仅需要和Leader机器建立起连接，并进行状态同步即可。</p><p>② 集群中不存在Leader：在集群中不存在Leader情况下则会相对复杂，其步骤如下</p><ol><li><p><strong>第一次投票</strong>。无论哪种导致进行Leader选举，集群的所有机器都处于试图选举出一个Leader的状态，即LOOKING状态，LOOKING机器会向所有其他机器发送消息，该消息称为投票。投票中包含了SID（服务器的唯一标识）和ZXID（事务ID），(SID, ZXID)形式来标识一次投票信息。假定Zookeeper由5台机器组成，SID分别为1、2、3、4、5，ZXID分别为9、9、9、8、8，并且此时SID为2的机器是Leader机器，某一时刻，1、2所在机器出现故障，因此集群开始进行Leader选举。在第一次投票时，每台机器都会将自己作为投票对象，于是SID为3、4、5的机器投票情况分别为(3, 9)，(4, 8)， (5, 8)。</p></li><li><p><strong>变更投票</strong>。每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个Leader选举算法的核心所在，其中术语描述如下</p><ul><li><b>vote_sid</b>：接收到的投票中所推举Leader服务器的SID。</li><li><b>vote_zxid</b>：接收到的投票中所推举Leader服务器的ZXID。</li><li><b>self_sid</b>：当前服务器自己的SID。</li><li><b>self_zxid</b>：当前服务器自己的ZXID。</li></ul><p>每次对收到的投票的处理，都是对(vote_sid, vote_zxid) 和 (self_sid, self_zxid)对比的过程。</p><ul><li>规则一：如果vote_zxid大于self_zxid，就认可当前收到的投票，并再次将该投票发送出去。</li><li>规则二：如果vote_zxid小于self_zxid，那么坚持自己的投票，不做任何变更。</li><li>规则三：如果vote_zxid等于self_zxid，那么就对比两者的SID，如果vote_sid大于self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。</li><li>规则四：如果vote_zxid等于self_zxid，并且vote_sid小于self_sid，那么坚持自己的投票，不做任何变更。</li></ul><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos/zookeeper/zookeeper9.png"></img></p></li><li><p><strong>确定Leader</strong>。经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的SID机器即为Leader。此时Server3将成为Leader。</p></li></ol><p>由上面规则可知，通常那台服务器上的数据越新（ZXID会越大），其成为Leader的可能性越大，也就越能够保证数据的恢复。如果ZXID相同，则SID越大机会越大。</p><h4 id="3-1-5-过半机制防止脑裂"><a href="#3-1-5-过半机制防止脑裂" class="headerlink" title="3.1.5 过半机制防止脑裂"></a>3.1.5 过半机制防止脑裂</h4><p><b>何为集群脑裂？</b></p><p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p><p>举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。</p><p><b>过半机制是如何防止脑裂现象产生的？</b></p><p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p><h3 id="3-2-Zookeeper集群搭建"><a href="#3-2-Zookeeper集群搭建" class="headerlink" title="3.2 Zookeeper集群搭建"></a>3.2 Zookeeper集群搭建</h3><h4 id="3-2-1搭建要求"><a href="#3-2-1搭建要求" class="headerlink" title="3.2.1搭建要求"></a>3.2.1搭建要求</h4><p>真实的集群是需要部署在不同的服务器上的，但是在我们测试时同时启动很多个虚拟机(ip)内存会吃不消，所以我们通常会搭建<strong>伪集群</strong>，也就是把所有的服务都搭建在一台虚拟机上，用端口(port)进行区分。</p><p>我们这里搭建一个三个节点的Zookeeper集群（伪集群）。</p><h4 id="3-2-2-准备工作"><a href="#3-2-2-准备工作" class="headerlink" title="3.2.2  准备工作"></a>3.2.2  准备工作</h4><p>重新部署一台虚拟机作为我们搭建集群的测试服务器。</p><p>（1）Zookeeper压缩包上传到服务器<br>（2）将Zookeeper解压 ，建立&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster目录，将解压后的Zookeeper复制到以下三个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /usr/local/zookeeper-cluster</span><br><span class="line">[root@localhost ~]# cp -r  apache-zookeeper-3.5.6-bin /usr/local/zookeeper-cluster/zookeeper-1</span><br><span class="line">[root@localhost ~]# cp -r  apache-zookeeper-3.5.6-bin /usr/local/zookeeper-cluster/zookeeper-2</span><br><span class="line">[root@localhost ~]# cp -r  apache-zookeeper-3.5.6-bin /usr/local/zookeeper-cluster/zookeeper-3</span><br></pre></td></tr></table></figure><p>（4）创建data目录 ，并且将 conf下zoo_sample.cfg 文件改名为 zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper-cluster/zookeeper-1/data</span><br><span class="line">mkdir /usr/local/zookeeper-cluster/zookeeper-2/data</span><br><span class="line">mkdir /usr/local/zookeeper-cluster/zookeeper-3/data</span><br><span class="line"></span><br><span class="line">mv  /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo_sample.cfg  /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg</span><br><span class="line">mv  /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo_sample.cfg  /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg</span><br><span class="line">mv  /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo_sample.cfg  /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg</span><br></pre></td></tr></table></figure><p>（5） 配置每一个Zookeeper 的dataDir 和 clientPort 分别为2181  2182  2183</p><p>Zookeeper ①：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-1/data</span><br></pre></td></tr></table></figure><p>Zookeeper ②：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">clientPort=2182</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-2/data</span><br></pre></td></tr></table></figure><p>Zookeeper ③：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">clientPort=2183</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-3/data</span><br></pre></td></tr></table></figure><h4 id="3-2-3-配置集群"><a href="#3-2-3-配置集群" class="headerlink" title="3.2.3 配置集群"></a>3.2.3 配置集群</h4><p>（1）在每个zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。这个文件就是记录每个服务器的ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;/usr/local/zookeeper-cluster/zookeeper-1/data/myid</span><br><span class="line">echo 2 &gt;/usr/local/zookeeper-cluster/zookeeper-2/data/myid</span><br><span class="line">echo 3 &gt;/usr/local/zookeeper-cluster/zookeeper-3/data/myid</span><br></pre></td></tr></table></figure><p>（2）在每一个zookeeper 的 zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表。</p><p>集群服务器IP列表如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg</span><br><span class="line">vim /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg</span><br><span class="line">vim /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">每个配置文件都添加：</span><br><span class="line">server.1=192.168.149.135:2881:3881</span><br><span class="line">server.2=192.168.149.135:2882:3882</span><br><span class="line">server.3=192.168.149.135:2883:3883</span><br></pre></td></tr></table></figure><p>解释：server.服务器ID&#x3D;服务器IP地址：服务器之间通信端口：服务器之间投票选举端口 </p><h4 id="3-2-4-启动集群"><a href="#3-2-4-启动集群" class="headerlink" title="3.2.4 启动集群"></a>3.2.4 启动集群</h4><p>启动集群就是分别启动每个实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh start</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh start</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><h4 id="3-2-5-模拟集群异常情况"><a href="#3-2-5-模拟集群异常情况" class="headerlink" title="3.2.5 模拟集群异常情况"></a>3.2.5 模拟集群异常情况</h4><p>（1）首先我们先测试如果是从服务器挂掉，会怎么样。把3号服务器停掉，观察1号和2号，发现状态并没有变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh status</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status</span><br></pre></td></tr></table></figure><p>由此得出结论，3个节点的集群，从服务器挂掉，集群正常</p><p>（2）我们再把1号服务器（从服务器）也停掉，查看2号（主服务器）的状态，发现已经停止运行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status</span><br></pre></td></tr></table></figure><p>由此得出结论，3个节点的集群，2个从服务器都挂掉，主服务器也无法运行。因为可运行的机器没有超过集群总数量的半数。</p><p>（3）我们再次把1号服务器启动起来，发现2号服务器又开始正常工作了。而且依然是领导者。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status </span><br></pre></td></tr></table></figure><p>（4）我们把3号服务器也启动起来，把2号服务器停掉,停掉后观察1号和3号的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh start</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh status</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh status </span><br></pre></td></tr></table></figure><p>发现新的leader产生了。</p><p>由此我们得出结论，当集群中的主服务器挂了，集群中的其他服务器会自动进行选举状态，然后产生新得leader </p><p>（5）我们再次测试，当我们把2号服务器重新启动起来启动后，会发生什么？2号服务器会再次成为新的领导吗？我们看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh status </span><br></pre></td></tr></table></figure><p>我们会发现，2号服务器启动后依然是跟随者（从服务器），3号服务器依然是领导者（主服务器），没有撼动3号服务器的领导地位。</p><p>由此我们得出结论，当领导者产生后，再次有新服务器加入集群，不会影响到现任领导者。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://www.cnblogs.com/leesf456/p/6107600.html">Zookeeper的Leader选举</a></p><p><a href="https://www.bilibili.com/video/BV1M741137qY?p=22&spm_id_from=pageDriver">黑马程序员快速入门zookeeper技术</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Zookeeper介绍&quot;&gt;&lt;a href=&quot;#1-Zookeeper介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Zookeeper介绍&quot;&gt;&lt;/a&gt;1.Zookeeper介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Zookeeper是一个开源的分布式的，</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="notebook" scheme="http://example.com/tags/notebook/"/>
    
  </entry>
  
  <entry>
    <title>Jvm内存模型八股文</title>
    <link href="http://example.com/2022/03/08/Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/03/08/Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-03-08T06:49:34.000Z</published>
    <updated>2022-06-01T10:39:47.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章为本人参考 <a href="https://javaguide.cn/java/jvm/memory-area.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">JavaGuide</a>，方便查阅记忆整理出来的。</p><h2 id="JVM-运行时数据区域"><a href="#JVM-运行时数据区域" class="headerlink" title="JVM 运行时数据区域"></a>JVM 运行时数据区域</h2><ul><li>线程私有：程序计数器，虚拟机栈</li><li>线程共享：堆，方法区，</li></ul><p><strong>JDK 1.8 之前</strong> ：</p><p><img src="https://javaguide.cn/assets/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.5f095134.png" alt="img"></p><p><strong>JDK 1.8</strong> ：</p><p><img src="https://javaguide.cn/assets/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.dbbe1f77.png" alt="img"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>①：是线程私有的，随线程创建而创建，随线程消亡而消亡</p><p>②：作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，实现了代码的流程控制</li><li>在多线程环境下，可以保存线程执行位置，待线程切换回来时继续执行</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>①：是线程私有的，随线程创建而创建，随线程消亡而消亡</p><p>②：方法调用数据需要通过栈进行传递，每次调用方法都会有对应栈帧被压入栈中。</p><p>③：栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183912.png" alt="图片" style="zoom: 50%;" /><ul><li>局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）</li><li>操作数栈：主要存储方法运行时产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</li><li>动态链接：将符号引用转化为内存中的直接引用（Java源文件被编译成字节码文件时，所有变量和方法引用都会作为符号引用存放在Class文件中的常量池中，如果想调用这些方法，就需要再把符号引用转换回直接引用）</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>①：跟虚拟机栈基本一致</p><p>②：虚拟机栈为 <code>Java </code> 方法服务，本地方法栈为 <code>native</code> 方法服务。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>①：内存共享</p><p>②：存放对象实例的地方</p><p>③：是垃圾管理器管理的主要区域，因此也被称作GC堆。Java堆可以细分为：新生代和老年代，再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好的回收内存，或者更快的分配内存。</p><p> 在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>而在JDK 8 版本后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存 </p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183846.png"></img></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。当累积的某个年龄的对象的数目大小超过了 survivor 区的一半时，取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>①：线程共享的内存区域，主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池</p><p>②：当虚拟机要使用一个类时，会读取并解析 Class 文件的相关信息，然后将这些信息存到方法区中，方法区中会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>③：方法区和永久代、元空间的关系：方法区相当于是个概念，而永久代和元空间是方法区的实现</p><p>④：把永久代换成元空间的因素：</p><ul><li>永久代存放在JVM中，受到JVM设置的固定大小上限。而元空间存放在直接内存中，溢出的可能性更小。</li><li>合并 HotSpot 和 JRockit 的代码时，JRockit 没有永久代这个东西。</li></ul><p>⑤：方法区常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。</p><h3 id="静态常量池"><a href="#静态常量池" class="headerlink" title="静态常量池"></a>静态常量池</h3><p>①：所谓静态常量池，即 <code>*.class</code> 文件中的常量池，字节码文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用字节码文件的绝大部分空间。它们只是一个类的描述信息而已，还没有具备被执行的能力</p><p>②：：Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量和符号引用的常量池表</p><p>②：常量池表会在加载后存放到方法区的运行时常量池中</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>①：运行时常量池，则是虚拟机在完成类装载操作后，将字节码文件中的常量池载入到内存并存入方法区的地方，我们常说的常量池，就是指方法区中的运行时常量池。</p><p>②：运行时常量池相对于静态常量池的另外一个重要特征就是具备动态性，Java语言并不要求常量一定只有在编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 <code>intern()</code> 方法.</p><p>③：字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。JDK 8 后存放在堆中</p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183826.png" alt="img" style="zoom: 80%;" /><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>①：直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>②：本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制</p><h2 id="异常解释"><a href="#异常解释" class="headerlink" title="异常解释"></a>异常解释</h2><p>①：<code>StackOverFlowError</code>： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>②：<code>OutOfMemoryError</code>：如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code> 错误。</p><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><ol><li><p>检查类加载：检查是否能在常量池中定位到这个类的符号引用，并检查类是否已经被加载过、解析过、初始化过。若没有则先进行类的加载过程</p></li><li><p>分配内存： </p><p>①：两种方式</p><ul><li>指针碰撞<ul><li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li><li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表<ul><li>适用场合 ： 堆内存不规整的情况下。</li><li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>②：内存分配并发问题</p><ul><li>TLAB：为每个线程预先在Eden区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大小大于 TLAB 的剩余内存或者 TLAB 已用尽时，采用CAS + 失败重试策略</li><li>CAS + 失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li></ul></li><li><p>初始化零值：将对象的实例字段初始化为这些字段对应类型的零值</p></li><li><p>设置对象头：对象头分为两部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">|                     Object Header (64 bits)                  |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">|        Mark Word (32 bits)         |    Klass Word (32 bits) |</span><br><span class="line">|------------------------------------|-------------------------|</span><br></pre></td></tr></table></figure><ul><li>Mark Word：主要保存 锁、Hash、还有分代年龄等信息</li><li>KClass Word：主要存放保存类元信息（存在于方法区）的指针</li></ul></li><li><p>执行 init 方法</p></li></ol><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><ol><li><p>使用句柄：在堆中开辟一块内存作为句柄池，存储对象实例数据和对象类型数据的指针</p><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183724.png"></img></p></li><li><p>直接指针：对象实例数据中包含有对象数据类型的指针</p></li></ol><p><img src="http://fastly.jsdelivr.net/gh/SoulChay/figureBed/blogPhotos\bagu\20220601183757.png"></img></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;文章为本人参考 &lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.htm</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
</feed>
